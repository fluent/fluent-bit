/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */

/*  CProfiles
 *  =========
 *  Copyright (C) 2024 The CProfiles Authors
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

#include <time.h>
#include "cprof_tests.h"
#include <cprofiles/cprof_decode_opentelemetry.h>
#include <cprofiles/cprof_encode_opentelemetry.h>
#include <cfl/cfl.h>
#include <opentelemetry/proto/collector/profiles/v1development/profiles_service.pb-c.h>

#include <stdio.h>
#include <inttypes.h>
#include <stdlib.h>
#include <string.h>

/*
 * Build a minimal cprof (resource_profiles -> scope_profiles -> profile with one sample)
 * so we can test OTLP encode then decode round-trip without depending on old wire data.
 */
static struct cprof *create_minimal_cprof(void)
{
    struct cprof                        *cprof;
    struct cprof_resource_profiles     *resource_profiles;
    struct cprof_resource              *resource;
    struct cprof_scope_profiles        *scope_profiles;
    struct cprof_profile               *profile;
    struct cprof_sample                *sample;
    struct cfl_kvlist                  *attrs;
    size_t                              id;
    int                                 ret;

    cprof = cprof_create();
    if (cprof == NULL) {
        return NULL;
    }

    resource_profiles = cprof_resource_profiles_create("");
    if (resource_profiles == NULL) {
        cprof_destroy(cprof);
        return NULL;
    }

    attrs = cfl_kvlist_create();
    if (attrs == NULL) {
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    resource = cprof_resource_create(attrs);
    if (resource == NULL) {
        cfl_kvlist_destroy(attrs);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    resource_profiles->resource = resource;

    scope_profiles = cprof_scope_profiles_create(resource_profiles, "");
    if (scope_profiles == NULL) {
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    scope_profiles->scope = cprof_instrumentation_scope_create("", "", NULL, 0);
    if (scope_profiles->scope == NULL) {
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }

    profile = cprof_profile_create();
    if (profile == NULL) {
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    profile->time_nanos = 1000000000ULL;
    profile->duration_nanos = 100000000ULL;

    cprof_sample_type_str_create(profile, "count", "", CPROF_AGGREGATION_TEMPORALITY_CUMULATIVE);
    id = cprof_profile_string_add(profile, "main", -1);
    if (id == 0) {
        cprof_profile_destroy(profile);
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }

    sample = cprof_sample_create(profile);
    if (sample == NULL) {
        cprof_profile_destroy(profile);
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    ret = cprof_sample_add_location_index(sample, id);
    if (ret != 0) {
        cprof_profile_destroy(profile);
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    ret = cprof_sample_add_value(sample, 1);
    if (ret != 0) {
        cprof_profile_destroy(profile);
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }

    cfl_list_add(&profile->_head, &scope_profiles->profiles);

    ret = cprof_resource_profiles_add(cprof, resource_profiles);
    if (ret != 0) {
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }

    return cprof;
}

/*
unsigned char encoded_packet[] = {  0x0A, 0x9F, 0x11, 0x0A, 0x72, 0x0A, 0x0E, 0x0A, 0x07, 0x68, 0x6F, 0x73, 0x74, 0x2E, 0x69, 0x64, 0x12, 0x03, 0x0A, 0x01, 0x30, 0x0A, 0x16, 0x0A, 0x07, 0x68, 0x6F, 0x73, 0x74, 0x2E, \
                                    0x69, 0x70, 0x12, 0x0B, 0x0A, 0x09, 0x31, 0x32, 0x37, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x31, 0x0A, 0x1B, 0x0A, 0x09, 0x68, 0x6F, 0x73, 0x74, 0x2E, 0x6E, 0x61, 0x6D, 0x65, 0x12, 0x0E, \
                                    0x0A, 0x0C, 0x6C, 0x69, 0x6D, 0x61, 0x2D, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x0A, 0x15, 0x0A, 0x0F, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2E, 0x76, 0x65, 0x72, 0x73, \
                                    0x69, 0x6F, 0x6E, 0x12, 0x02, 0x0A, 0x00, 0x0A, 0x14, 0x0A, 0x09, 0x6F, 0x73, 0x2E, 0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x12, 0x07, 0x0A, 0x05, 0x36, 0x2E, 0x35, 0x2E, 0x30, 0x12, \
                                    0xA8, 0x10, 0x0A, 0x00, 0x12, 0xA3, 0x10, 0x0A, 0x10, 0xA4, 0x58, 0x33, 0xE6, 0x18, 0xE6, 0x34, 0x8D, 0xD6, 0xFE, 0x00, 0x58, 0x56, 0xF5, 0xA7, 0x54, 0x11, 0x69, 0x39, 0xAC, 0x2C, \
                                    0x53, 0xC7, 0x04, 0x18, 0x19, 0x69, 0x39, 0xAC, 0x2C, 0x53, 0xC7, 0x04, 0x18, 0x42, 0xFC, 0x0F, 0x0A, 0x04, 0x08, 0x01, 0x10, 0x02, 0x12, 0x16, 0x12, 0x01, 0x01, 0x40, 0x05, 0x48, \
                                    0x05, 0x52, 0x02, 0x01, 0x02, 0x6A, 0x09, 0xF6, 0xEA, 0xCA, 0xD2, 0xAC, 0xEA, 0xB1, 0x82, 0x18, 0x12, 0x18, 0x12, 0x01, 0x01, 0x38, 0x05, 0x40, 0x0E, 0x48, 0x07, 0x52, 0x02, 0x06, \
                                    0x07, 0x6A, 0x09, 0xA8, 0xD3, 0xE3, 0x8E, 0xB1, 0xEA, 0xB1, 0x82, 0x18, 0x12, 0x18, 0x12, 0x01, 0x01, 0x38, 0x13, 0x40, 0x12, 0x48, 0x09, 0x52, 0x02, 0x09, 0x0A, 0x6A, 0x09, 0xE9, \
                                    0xF2, 0xB0, 0xE5, 0xB2, 0xEA, 0xB1, 0x82, 0x18, 0x1A, 0x04, 0x30, 0x06, 0x58, 0x01, 0x1A, 0x10, 0x10, 0x80, 0x80, 0x80, 0x02, 0x18, 0x80, 0x80, 0xF4, 0x08, 0x28, 0x08, 0x62, 0x02, \
                                    0x04, 0x05, 0x1A, 0x0E, 0x10, 0x80, 0x80, 0x04, 0x18, 0x80, 0xC0, 0xFB, 0x07, 0x28, 0x0A, 0x62, 0x01, 0x08, 0x22, 0x0B, 0x18, 0xDB, 0xC1, 0x43, 0x22, 0x02, 0x08, 0x01, 0x3A, 0x01, \
                                    0x00, 0x22, 0x0C, 0x18, 0xC7, 0x8B, 0xD2, 0x0A, 0x22, 0x02, 0x08, 0x02, 0x3A, 0x01, 0x00, 0x22, 0x0B, 0x18, 0xB7, 0x94, 0x3A, 0x22, 0x02, 0x08, 0x03, 0x3A, 0x01, 0x00, 0x22, 0x0B, \
                                    0x18, 0xF7, 0x96, 0x3D, 0x22, 0x02, 0x08, 0x04, 0x3A, 0x01, 0x00, 0x22, 0x0B, 0x18, 0x87, 0xFA, 0x01, 0x22, 0x02, 0x08, 0x05, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0xC3, 0xD6, 0xA1, \
                                    0x02, 0x22, 0x02, 0x08, 0x06, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0xBB, 0xB5, 0xB3, 0x02, 0x22, 0x02, 0x08, 0x07, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0xE7, 0xB7, 0xB3, 0x02, 0x22, \
                                    0x02, 0x08, 0x08, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0x93, 0xD5, 0xB9, 0x01, 0x22, 0x02, 0x08, 0x09, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0xD7, 0x8C, 0xB8, 0x01, 0x22, 0x02, 0x08, \
                                    0x0A, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0x97, 0x93, 0xBA, 0x01, 0x22, 0x02, 0x08, 0x0B, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0x9F, 0xA8, 0xBA, 0x01, 0x22, 0x02, 0x08, 0x0C, 0x3A, \
                                    0x01, 0x00, 0x22, 0x0B, 0x18, 0xEB, 0xFA, 0x08, 0x22, 0x02, 0x08, 0x0D, 0x3A, 0x01, 0x00, 0x22, 0x0B, 0x18, 0xD3, 0xFE, 0x08, 0x22, 0x02, 0x08, 0x0E, 0x3A, 0x01, 0x00, 0x22, 0x0B, \
                                    0x18, 0xB7, 0xFF, 0x08, 0x22, 0x02, 0x08, 0x0F, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0xA7, 0xBD, 0xCF, 0x0A, 0x22, 0x02, 0x08, 0x10, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0xCF, 0xCA, \
                                    0xCF, 0x0A, 0x22, 0x02, 0x08, 0x11, 0x3A, 0x01, 0x00, 0x22, 0x0A, 0x18, 0xC7, 0x3C, 0x22, 0x02, 0x08, 0x12, 0x3A, 0x01, 0x00, 0x22, 0x0A, 0x10, 0x01, 0x18, 0x9F, 0xA6, 0x81, 0x02, \
                                    0x3A, 0x01, 0x03, 0x22, 0x0C, 0x18, 0x9F, 0xCD, 0xA9, 0x02, 0x22, 0x02, 0x08, 0x13, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0xC3, 0xDF, 0xAC, 0x02, 0x22, 0x02, 0x08, 0x14, 0x3A, 0x01, \
                                    0x00, 0x22, 0x0C, 0x18, 0xB3, 0x9F, 0xAD, 0x02, 0x22, 0x02, 0x08, 0x15, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0x9B, 0xE1, 0xA0, 0x02, 0x22, 0x02, 0x08, 0x16, 0x3A, 0x01, 0x00, 0x22, \
                                    0x0C, 0x18, 0xCB, 0xE8, 0x86, 0x09, 0x22, 0x02, 0x08, 0x17, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0xEB, 0xE3, 0x87, 0x09, 0x22, 0x02, 0x08, 0x18, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, \
                                    0xFB, 0xAE, 0xFE, 0x09, 0x22, 0x02, 0x08, 0x19, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0xE7, 0xB0, 0xFE, 0x09, 0x22, 0x02, 0x08, 0x1A, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0xEF, 0x90, \
                                    0x85, 0x09, 0x22, 0x02, 0x08, 0x1B, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0xF7, 0xF3, 0x85, 0x09, 0x22, 0x02, 0x08, 0x1C, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0xCB, 0xF5, 0x85, 0x09, \
                                    0x22, 0x02, 0x08, 0x1D, 0x3A, 0x01, 0x00, 0x22, 0x0B, 0x18, 0xEB, 0xFA, 0x08, 0x22, 0x02, 0x08, 0x0D, 0x3A, 0x01, 0x00, 0x22, 0x0B, 0x18, 0xD3, 0xFE, 0x08, 0x22, 0x02, 0x08, 0x0E, \
                                    0x3A, 0x01, 0x00, 0x22, 0x0B, 0x18, 0xB7, 0xFF, 0x08, 0x22, 0x02, 0x08, 0x0F, 0x3A, 0x01, 0x00, 0x22, 0x0C, 0x18, 0xA7, 0xBD, 0xCF, 0x0A, 0x22, 0x02, 0x08, 0x10, 0x3A, 0x01, 0x00, \
                                    0x22, 0x0C, 0x18, 0xCF, 0xCA, 0xCF, 0x0A, 0x22, 0x02, 0x08, 0x11, 0x3A, 0x01, 0x00, 0x22, 0x0A, 0x18, 0xC7, 0x3C, 0x22, 0x02, 0x08, 0x12, 0x3A, 0x01, 0x00, 0x22, 0x09, 0x10, 0x02, \
                                    0x18, 0xAF, 0xBF, 0x05, 0x3A, 0x01, 0x03, 0x2A, 0x00, 0x2A, 0x02, 0x10, 0x18, 0x2A, 0x02, 0x10, 0x10, 0x2A, 0x02, 0x10, 0x24, 0x2A, 0x02, 0x10, 0x19, 0x2A, 0x02, 0x10, 0x21, 0x2A, \
                                    0x02, 0x10, 0x1A, 0x2A, 0x02, 0x10, 0x25, 0x2A, 0x02, 0x10, 0x0B, 0x2A, 0x02, 0x10, 0x26, 0x2A, 0x02, 0x10, 0x11, 0x2A, 0x02, 0x10, 0x14, 0x2A, 0x02, 0x10, 0x15, 0x2A, 0x02, 0x10, \
                                    0x12, 0x2A, 0x02, 0x10, 0x22, 0x2A, 0x02, 0x10, 0x16, 0x2A, 0x02, 0x10, 0x0E, 0x2A, 0x02, 0x10, 0x1B, 0x2A, 0x02, 0x10, 0x1E, 0x2A, 0x02, 0x10, 0x17, 0x2A, 0x02, 0x10, 0x27, 0x2A, \
                                    0x02, 0x10, 0x0C, 0x2A, 0x02, 0x10, 0x13, 0x2A, 0x02, 0x10, 0x1F, 0x2A, 0x02, 0x10, 0x23, 0x2A, 0x02, 0x10, 0x0F, 0x2A, 0x02, 0x10, 0x1C, 0x2A, 0x02, 0x10, 0x0D, 0x2A, 0x02, 0x10, \
                                    0x20, 0x2A, 0x02, 0x10, 0x1D, 0x32, 0x00, 0x32, 0x07, 0x73, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x73, 0x32, 0x05, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x32, 0x03, 0x63, 0x70, 0x75, 0x32, 0x0B, \
                                    0x6E, 0x61, 0x6E, 0x6F, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x32, 0x16, 0x41, 0x54, 0x73, 0x51, 0x46, 0x31, 0x72, 0x72, 0x49, 0x63, 0x30, 0x35, 0x74, 0x65, 0x6A, 0x66, 0x79, \
                                    0x65, 0x73, 0x5A, 0x52, 0x77, 0x32, 0x20, 0x62, 0x61, 0x31, 0x63, 0x39, 0x61, 0x35, 0x61, 0x38, 0x32, 0x35, 0x36, 0x61, 0x36, 0x65, 0x66, 0x33, 0x65, 0x36, 0x36, 0x33, 0x63, 0x63, \
                                    0x37, 0x33, 0x31, 0x36, 0x38, 0x30, 0x33, 0x64, 0x39, 0x32, 0x16, 0x7A, 0x6A, 0x32, 0x51, 0x75, 0x43, 0x52, 0x61, 0x70, 0x75, 0x6E, 0x30, 0x32, 0x73, 0x79, 0x68, 0x6C, 0x41, 0x48, \
                                    0x71, 0x54, 0x77, 0x32, 0x0D, 0x65, 0x62, 0x70, 0x66, 0x2D, 0x70, 0x72, 0x6F, 0x66, 0x69, 0x6C, 0x65, 0x72, 0x32, 0x16, 0x36, 0x34, 0x41, 0x49, 0x75, 0x76, 0x39, 0x69, 0x70, 0x47, \
                                    0x42, 0x41, 0x41, 0x64, 0x30, 0x52, 0x5A, 0x6D, 0x76, 0x4C, 0x4C, 0x77, 0x32, 0x0A, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x65, 0x72, 0x64, 0x32, 0x13, 0x5F, 0x5F, 0x63, 0x68, \
                                    0x65, 0x63, 0x6B, 0x5F, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x5F, 0x73, 0x69, 0x7A, 0x65, 0x32, 0x11, 0x6F, 0x62, 0x6A, 0x5F, 0x63, 0x67, 0x72, 0x6F, 0x75, 0x70, 0x5F, 0x63, 0x68, \
                                    0x61, 0x72, 0x67, 0x65, 0x32, 0x0D, 0x5F, 0x5F, 0x73, 0x6F, 0x63, 0x6B, 0x5F, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x32, 0x07, 0x65, 0x6C, 0x30, 0x5F, 0x73, 0x76, 0x63, 0x32, 0x0C, \
                                    0x75, 0x6E, 0x69, 0x78, 0x5F, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x31, 0x32, 0x08, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6C, 0x65, 0x32, 0x10, 0x62, 0x70, 0x66, 0x5F, 0x6D, 0x61, \
                                    0x70, 0x5F, 0x64, 0x6F, 0x5F, 0x62, 0x61, 0x74, 0x63, 0x68, 0x32, 0x0E, 0x69, 0x6E, 0x76, 0x6F, 0x6B, 0x65, 0x5F, 0x73, 0x79, 0x73, 0x63, 0x61, 0x6C, 0x6C, 0x32, 0x10, 0x6B, 0x6D, \
                                    0x65, 0x6D, 0x5F, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5F, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x32, 0x09, 0x5F, 0x5F, 0x73, 0x79, 0x73, 0x5F, 0x62, 0x70, 0x66, 0x32, 0x0F, 0x5F, 0x5F, 0x61, \
                                    0x72, 0x6D, 0x36, 0x34, 0x5F, 0x73, 0x79, 0x73, 0x5F, 0x62, 0x70, 0x66, 0x32, 0x0A, 0x64, 0x6F, 0x5F, 0x65, 0x6C, 0x30, 0x5F, 0x73, 0x76, 0x63, 0x32, 0x19, 0x70, 0x72, 0x6F, 0x70, \
                                    0x61, 0x67, 0x61, 0x74, 0x65, 0x5F, 0x70, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x5F, 0x75, 0x73, 0x61, 0x67, 0x65, 0x32, 0x19, 0x66, 0x69, 0x6E, 0x69, 0x73, 0x68, 0x5F, \
                                    0x74, 0x61, 0x73, 0x6B, 0x5F, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x2E, 0x69, 0x73, 0x72, 0x61, 0x2E, 0x30, 0x32, 0x07, 0x6B, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x32, 0x13, 0x5F, \
                                    0x5F, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x5F, 0x68, 0x65, 0x61, 0x70, 0x5F, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x32, 0x14, 0x65, 0x6C, 0x30, 0x74, 0x5F, 0x36, 0x34, 0x5F, 0x73, 0x79, \
                                    0x6E, 0x63, 0x5F, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x32, 0x0B, 0x75, 0x6E, 0x69, 0x78, 0x5F, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x32, 0x12, 0x5F, 0x5F, 0x61, 0x72, 0x6D, \
                                    0x36, 0x34, 0x5F, 0x73, 0x79, 0x73, 0x5F, 0x73, 0x6F, 0x63, 0x6B, 0x65, 0x74, 0x32, 0x0C, 0x65, 0x6C, 0x30, 0x74, 0x5F, 0x36, 0x34, 0x5F, 0x73, 0x79, 0x6E, 0x63, 0x32, 0x0D, 0x73, \
                                    0x6B, 0x5F, 0x70, 0x72, 0x6F, 0x74, 0x5F, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x32, 0x0C, 0x5F, 0x5F, 0x73, 0x79, 0x73, 0x5F, 0x73, 0x6F, 0x63, 0x6B, 0x65, 0x74, 0x32, 0x0D, 0x72, 0x65, \
                                    0x74, 0x5F, 0x66, 0x72, 0x6F, 0x6D, 0x5F, 0x66, 0x6F, 0x72, 0x6B, 0x32, 0x1A, 0x65, 0x6C, 0x30, 0x5F, 0x73, 0x76, 0x63, 0x5F, 0x63, 0x6F, 0x6D, 0x6D, 0x6F, 0x6E, 0x2E, 0x63, 0x6F, \
                                    0x6E, 0x73, 0x74, 0x70, 0x72, 0x6F, 0x70, 0x2E, 0x30, 0x32, 0x08, 0x73, 0x6B, 0x5F, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x32, 0x0D, 0x77, 0x6F, 0x72, 0x6B, 0x65, 0x72, 0x5F, 0x74, 0x68, \
                                    0x72, 0x65, 0x61, 0x64, 0x32, 0x1A, 0x5F, 0x5F, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x5F, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x5F, 0x73, 0x69, 0x7A, 0x65, 0x2E, 0x70, 0x61, 0x72, 0x74, \
                                    0x2E, 0x30, 0x32, 0x18, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x69, 0x63, 0x5F, 0x6D, 0x61, 0x70, 0x5F, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5F, 0x62, 0x61, 0x74, 0x63, 0x68, 0x32, 0x10, \
                                    0x74, 0x72, 0x79, 0x5F, 0x63, 0x68, 0x61, 0x72, 0x67, 0x65, 0x5F, 0x6D, 0x65, 0x6D, 0x63, 0x67, 0x48, 0xE9, 0xF2, 0xB0, 0xE5, 0xB2, 0xEA, 0xB1, 0x82, 0x18, 0x5A, 0x04, 0x08, 0x03, \
                                    0x10, 0x04, 0x60, 0x80, 0xE1, 0xEB, 0x17, 0x7A, 0x25, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, \
                                    0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x82, 0x01, 0x1E, 0x0A, 0x12, 0x70, 0x72, 0x6F, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x66, \
                                    0x72, 0x61, 0x6D, 0x65, 0x2E, 0x74, 0x79, 0x70, 0x65, 0x12, 0x08, 0x0A, 0x06, 0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x82, 0x01, 0x13, 0x0A, 0x0C, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, \
                                    0x6E, 0x65, 0x72, 0x2E, 0x69, 0x64, 0x12, 0x03, 0x0A, 0x01, 0x2F, 0x82, 0x01, 0x1C, 0x0A, 0x0B, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2E, 0x6E, 0x61, 0x6D, 0x65, 0x12, 0x0D, 0x0A, \
                                    0x0B, 0x6B, 0x77, 0x6F, 0x72, 0x6B, 0x65, 0x72, 0x2F, 0x36, 0x3A, 0x31, 0x82, 0x01, 0x1E, 0x0A, 0x12, 0x70, 0x72, 0x6F, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x66, 0x72, 0x61, 0x6D, 0x65, \
                                    0x2E, 0x74, 0x79, 0x70, 0x65, 0x12, 0x08, 0x0A, 0x06, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x82, 0x01, 0x4D, 0x0A, 0x1F, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x2E, 0x65, 0x78, \
                                    0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x62, 0x75, 0x69, 0x6C, 0x64, 0x5F, 0x69, 0x64, 0x2E, 0x67, 0x6E, 0x75, 0x12, 0x2A, 0x0A, 0x28, 0x33, 0x34, 0x31, 0x39, 0x61, \
                                    0x33, 0x65, 0x66, 0x30, 0x30, 0x31, 0x35, 0x34, 0x35, 0x64, 0x38, 0x65, 0x65, 0x39, 0x66, 0x63, 0x64, 0x34, 0x62, 0x31, 0x38, 0x64, 0x34, 0x63, 0x65, 0x31, 0x37, 0x32, 0x30, 0x35, \
                                    0x37, 0x65, 0x33, 0x33, 0x39, 0x82, 0x01, 0x4B, 0x0A, 0x25, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x2E, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x62, \
                                    0x75, 0x69, 0x6C, 0x64, 0x5F, 0x69, 0x64, 0x2E, 0x70, 0x72, 0x6F, 0x66, 0x69, 0x6C, 0x69, 0x6E, 0x67, 0x12, 0x22, 0x0A, 0x20, 0x37, 0x30, 0x35, 0x62, 0x64, 0x66, 0x31, 0x34, 0x39, \
                                    0x38, 0x30, 0x66, 0x32, 0x63, 0x32, 0x32, 0x64, 0x63, 0x34, 0x64, 0x65, 0x32, 0x65, 0x36, 0x35, 0x37, 0x36, 0x65, 0x64, 0x66, 0x66, 0x38, 0x82, 0x01, 0x3C, 0x0A, 0x0C, 0x63, 0x6F, \
                                    0x6E, 0x74, 0x61, 0x69, 0x6E, 0x65, 0x72, 0x2E, 0x69, 0x64, 0x12, 0x2C, 0x0A, 0x2A, 0x2F, 0x75, 0x73, 0x65, 0x72, 0x2E, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x2F, 0x75, 0x73, 0x65, 0x72, \
                                    0x2D, 0x35, 0x30, 0x31, 0x2E, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x2F, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x2D, 0x32, 0x2E, 0x73, 0x63, 0x6F, 0x70, 0x65, 0x82, 0x01, 0x1E, 0x0A, \
                                    0x0B, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2E, 0x6E, 0x61, 0x6D, 0x65, 0x12, 0x0F, 0x0A, 0x0D, 0x65, 0x62, 0x70, 0x66, 0x2D, 0x70, 0x72, 0x6F, 0x66, 0x69, 0x6C, 0x65, 0x72, 0x82, \
                                    0x01, 0x4B, 0x0A, 0x25, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x2E, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x62, 0x75, 0x69, 0x6C, 0x64, 0x5F, 0x69, \
                                    0x64, 0x2E, 0x70, 0x72, 0x6F, 0x66, 0x69, 0x6C, 0x69, 0x6E, 0x67, 0x12, 0x22, 0x0A, 0x20, 0x64, 0x37, 0x38, 0x30, 0x31, 0x36, 0x30, 0x34, 0x65, 0x38, 0x62, 0x38, 0x39, 0x64, 0x64, \
                                    0x61, 0x63, 0x66, 0x65, 0x31, 0x39, 0x38, 0x39, 0x39, 0x64, 0x36, 0x62, 0x61, 0x33, 0x35, 0x36, 0x34, 0x82, 0x01, 0x5A, 0x0A, 0x0C, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x65, \
                                    0x72, 0x2E, 0x69, 0x64, 0x12, 0x4A, 0x0A, 0x48, 0x2F, 0x75, 0x73, 0x65, 0x72, 0x2E, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x2F, 0x75, 0x73, 0x65, 0x72, 0x2D, 0x35, 0x30, 0x31, 0x2E, 0x73, \
                                    0x6C, 0x69, 0x63, 0x65, 0x2F, 0x75, 0x73, 0x65, 0x72, 0x40, 0x35, 0x30, 0x31, 0x2E, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2F, 0x61, 0x70, 0x70, 0x2E, 0x73, 0x6C, 0x69, 0x63, \
                                    0x65, 0x2F, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x65, 0x72, 0x64, 0x2E, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x82, 0x01, 0x1B, 0x0A, 0x0B, 0x74, 0x68, 0x72, 0x65, 0x61, \
                                    0x64, 0x2E, 0x6E, 0x61, 0x6D, 0x65, 0x12, 0x0C, 0x0A, 0x0A, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x65, 0x72, 0x64
                                };
*/


/* Encode minimal cprof to OTLP and check success. */
static void test_encoder()
{
    cfl_sds_t     otlp_result;
    struct cprof *context;
    int           result;

    context = create_minimal_cprof();
    TEST_CHECK(context != NULL);
    if (context == NULL) {
        return;
    }

    result = cprof_encode_opentelemetry_create(&otlp_result, context);
    TEST_CHECK(result == CPROF_ENCODE_OPENTELEMETRY_SUCCESS);

    if (result == CPROF_ENCODE_OPENTELEMETRY_SUCCESS && otlp_result != NULL) {
        cprof_encode_opentelemetry_destroy(otlp_result);
    }
    cprof_destroy(context);
}

/* Round-trip: encode minimal cprof to OTLP, decode it back, assert decode success. */
static void test_decoder()
{
    cfl_sds_t     otlp_result;
    struct cprof *encoded_context;
    struct cprof *decoded_context;
    int           result;
    size_t        offset;

    encoded_context = create_minimal_cprof();
    TEST_CHECK(encoded_context != NULL);
    if (encoded_context == NULL) {
        return;
    }

    result = cprof_encode_opentelemetry_create(&otlp_result, encoded_context);
    TEST_CHECK(result == CPROF_ENCODE_OPENTELEMETRY_SUCCESS);
    cprof_destroy(encoded_context);
    if (result != CPROF_ENCODE_OPENTELEMETRY_SUCCESS || otlp_result == NULL) {
        return;
    }

    offset = 0;
    decoded_context = NULL;
    result = cprof_decode_opentelemetry_create(&decoded_context,
                                               (unsigned char *) otlp_result,
                                               cfl_sds_len(otlp_result),
                                               &offset);
    TEST_CHECK(result == CPROF_DECODE_OPENTELEMETRY_SUCCESS);

    if (result == CPROF_DECODE_OPENTELEMETRY_SUCCESS && decoded_context != NULL) {
        cprof_decode_opentelemetry_destroy(decoded_context);
    }
    cprof_encode_opentelemetry_destroy(otlp_result);
}

/*
 * Build a cprof with dictionary tables populated: one mapping, one function,
 * one location (with one line), one sample referencing that location, and
 * optionally one link. Exercises mapping_table, function_table, location_table,
 * stack_table (with real location indices), and link_table.
 */
static struct cprof *create_cprof_with_dictionary_tables(void)
{
    struct cprof                  *cprof;
    struct cprof_resource_profiles *resource_profiles;
    struct cprof_resource         *resource;
    struct cprof_scope_profiles   *scope_profiles;
    struct cprof_profile          *profile;
    struct cprof_sample           *sample;
    struct cprof_mapping          *mapping;
    struct cprof_function         *func;
    struct cprof_location         *loc;
    struct cprof_line             *line;
    struct cprof_link             *link;
    struct cfl_kvlist             *attrs;
    size_t                         id_bin;
    size_t                         id_foo;
    int                            ret;

    cprof = cprof_create();
    if (cprof == NULL) {
        return NULL;
    }

    resource_profiles = cprof_resource_profiles_create("");
    if (resource_profiles == NULL) {
        cprof_destroy(cprof);
        return NULL;
    }

    attrs = cfl_kvlist_create();
    if (attrs == NULL) {
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    resource = cprof_resource_create(attrs);
    if (resource == NULL) {
        cfl_kvlist_destroy(attrs);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    resource_profiles->resource = resource;

    scope_profiles = cprof_scope_profiles_create(resource_profiles, "");
    if (scope_profiles == NULL) {
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    scope_profiles->scope = cprof_instrumentation_scope_create("", "", NULL, 0);
    if (scope_profiles->scope == NULL) {
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }

    profile = cprof_profile_create();
    if (profile == NULL) {
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    profile->time_nanos = 2000000000ULL;
    profile->duration_nanos = 200000000ULL;

    cprof_sample_type_str_create(profile, "count", "", CPROF_AGGREGATION_TEMPORALITY_CUMULATIVE);
    id_bin = cprof_profile_string_add(profile, "/bin/app", -1);
    id_foo = cprof_profile_string_add(profile, "foo", -1);
    if (id_bin == 0 || id_foo == 0) {
        cprof_profile_destroy(profile);
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }

    /* One mapping (dict mapping_table will have zero + this). */
    mapping = cprof_mapping_create(profile);
    if (mapping == NULL) {
        cprof_profile_destroy(profile);
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    mapping->memory_start = 0x1000ULL;
    mapping->memory_limit = 0x2000ULL;
    mapping->file_offset = 0;
    mapping->filename = (int64_t)id_bin;

    /* One function (dict function_table will have zero + this). */
    func = cprof_function_create(profile);
    if (func == NULL) {
        cprof_profile_destroy(profile);
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    func->name = (int64_t)id_foo;
    func->system_name = (int64_t)id_foo;
    func->filename = 0;
    func->start_line = 10;

    /* One location with one line (dict location_table will have zero + this). */
    loc = cprof_location_create(profile);
    if (loc == NULL) {
        cprof_profile_destroy(profile);
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    loc->mapping_index = 0;
    loc->address = 0x1000ULL;
    line = cprof_line_create(loc);
    if (line == NULL) {
        cprof_profile_destroy(profile);
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    line->function_index = 0;
    line->line = 10;
    line->column = 0;

    /* One link (dict link_table will have zero + this). */
    link = cprof_link_create(profile);
    if (link == NULL) {
        cprof_profile_destroy(profile);
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    link->trace_id[0] = 0x01;
    link->trace_id[15] = 0x0f;
    link->span_id[0] = 0xaa;
    link->span_id[7] = 0xbb;

    /* Sample with location_index 0 (first location) and link 0. */
    sample = cprof_sample_create(profile);
    if (sample == NULL) {
        cprof_profile_destroy(profile);
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    ret = cprof_sample_add_location_index(sample, 0);
    if (ret != 0) {
        cprof_profile_destroy(profile);
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    ret = cprof_sample_add_value(sample, 42);
    if (ret != 0) {
        cprof_profile_destroy(profile);
        cprof_scope_profiles_destroy(scope_profiles);
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }
    sample->link = 0; /* index into profile->link_table (first link). */

    cfl_list_add(&profile->_head, &scope_profiles->profiles);

    ret = cprof_resource_profiles_add(cprof, resource_profiles);
    if (ret != 0) {
        cprof_resource_profiles_destroy(resource_profiles);
        cprof_destroy(cprof);
        return NULL;
    }

    return cprof;
}

/* Encode cprof with full dictionary (mappings, functions, locations, links) and check success. */
static void test_encoder_dictionary_tables()
{
    cfl_sds_t     otlp_result;
    struct cprof *context;
    int           result;

    context = create_cprof_with_dictionary_tables();
    TEST_CHECK(context != NULL);
    if (context == NULL) {
        return;
    }

    result = cprof_encode_opentelemetry_create(&otlp_result, context);
    TEST_CHECK(result == CPROF_ENCODE_OPENTELEMETRY_SUCCESS);

    if (result == CPROF_ENCODE_OPENTELEMETRY_SUCCESS && otlp_result != NULL) {
        cprof_encode_opentelemetry_destroy(otlp_result);
    }
    cprof_destroy(context);
}

/*
 * Verify decoded cprof matches the structure produced by create_cprof_with_dictionary_tables.
 * Decoder may emit dictionary sentinel at index 0 plus our entry, so we require at least 1
 * and find the entry matching our data. This guards against breaking changes in encode/decode.
 */
static void verify_decoded_cprof_dictionary_tables(struct cprof *decoded)
{
    struct cprof_resource_profiles     *rp;
    struct cprof_scope_profiles        *sp;
    struct cprof_profile               *profile;
    struct cprof_mapping               *mapping;
    struct cprof_function              *func;
    struct cprof_location             *loc;
    struct cprof_line                 *line;
    struct cprof_link                 *link;
    struct cprof_sample               *sample;
    struct cfl_list                   *rp_iter;
    struct cfl_list                   *sp_iter;
    struct cfl_list                   *prof_iter;
    struct cfl_list                   *map_iter;
    struct cfl_list                   *func_iter;
    struct cfl_list                   *loc_iter;
    struct cfl_list                   *line_iter;
    struct cfl_list                   *link_iter;
    struct cfl_list                   *sample_iter;
    size_t                              i;
    int                                 found_bin_app;
    int                                 found_foo;
    int                                 found_mapping;
    int                                 found_function;
    int                                 found_location;
    int                                 found_link;

    TEST_CHECK(decoded != NULL);
    if (decoded == NULL) {
        return;
    }

    TEST_CHECK(cfl_list_size(&decoded->profiles) == 1);
    if (cfl_list_size(&decoded->profiles) != 1) {
        return;
    }

    rp_iter = decoded->profiles.next;
    rp = cfl_list_entry(rp_iter, struct cprof_resource_profiles, _head);
    TEST_CHECK(cfl_list_size(&rp->scope_profiles) == 1);
    if (cfl_list_size(&rp->scope_profiles) != 1) {
        return;
    }

    sp_iter = rp->scope_profiles.next;
    sp = cfl_list_entry(sp_iter, struct cprof_scope_profiles, _head);
    TEST_CHECK(cfl_list_size(&sp->profiles) == 1);
    if (cfl_list_size(&sp->profiles) != 1) {
        return;
    }

    prof_iter = sp->profiles.next;
    profile = cfl_list_entry(prof_iter, struct cprof_profile, _head);

    /* Profile metadata */
    TEST_CHECK(profile->time_nanos == 2000000000ULL);
    TEST_CHECK(profile->duration_nanos == 200000000ULL);

    /* At least one mapping; find one with memory_start=0x1000, filename "/bin/app" */
    TEST_CHECK(cfl_list_size(&profile->mappings) >= 1);
    found_mapping = 0;
    for (map_iter = profile->mappings.next; map_iter != &profile->mappings; map_iter = map_iter->next) {
        mapping = cfl_list_entry(map_iter, struct cprof_mapping, _head);
        if (mapping->memory_start == 0x1000ULL && mapping->memory_limit == 0x2000ULL &&
            mapping->file_offset == 0) {
            if (mapping->filename >= 0 && (size_t)mapping->filename < profile->string_table_count &&
                profile->string_table[mapping->filename] != NULL &&
                strcmp(profile->string_table[mapping->filename], "/bin/app") == 0) {
                found_mapping = 1;
                break;
            }
        }
    }
    TEST_CHECK(found_mapping && "decoded profile must have mapping with /bin/app");

    /* At least one function; find one with start_line=10, name "foo" */
    TEST_CHECK(cfl_list_size(&profile->functions) >= 1);
    found_function = 0;
    for (func_iter = profile->functions.next; func_iter != &profile->functions; func_iter = func_iter->next) {
        func = cfl_list_entry(func_iter, struct cprof_function, _head);
        if (func->start_line == 10) {
            if (func->name >= 0 && (size_t)func->name < profile->string_table_count &&
                profile->string_table[func->name] != NULL &&
                strcmp(profile->string_table[func->name], "foo") == 0) {
                found_function = 1;
                break;
            }
        }
    }
    TEST_CHECK(found_function && "decoded profile must have function \"foo\" with start_line 10");

    /* At least one location; find one with address=0x1000, one line with line=10 */
    TEST_CHECK(cfl_list_size(&profile->locations) >= 1);
    found_location = 0;
    for (loc_iter = profile->locations.next; loc_iter != &profile->locations; loc_iter = loc_iter->next) {
        loc = cfl_list_entry(loc_iter, struct cprof_location, _head);
        if (loc->address == 0x1000ULL && cfl_list_size(&loc->lines) >= 1) {
            line_iter = loc->lines.next;
            line = cfl_list_entry(line_iter, struct cprof_line, _head);
            if (line->line == 10) {
                found_location = 1;
                break;
            }
        }
    }
    TEST_CHECK(found_location && "decoded profile must have location at 0x1000 with line 10");

    /* At least one link; find one with trace_id[0]=0x01, span_id[0]=0xaa */
    TEST_CHECK(cfl_list_size(&profile->link_table) >= 1);
    found_link = 0;
    for (link_iter = profile->link_table.next; link_iter != &profile->link_table; link_iter = link_iter->next) {
        link = cfl_list_entry(link_iter, struct cprof_link, _head);
        if (link->trace_id[0] == 0x01 && link->trace_id[15] == 0x0f &&
            link->span_id[0] == (uint8_t)0xaa && link->span_id[7] == (uint8_t)0xbb) {
            found_link = 1;
            break;
        }
    }
    TEST_CHECK(found_link && "decoded profile must have link with expected trace_id/span_id");

    /* Exactly one sample: value 42, at least one location_index, link index 0 or matching link */
    TEST_CHECK(cfl_list_size(&profile->samples) == 1);
    if (cfl_list_size(&profile->samples) == 1) {
        sample_iter = profile->samples.next;
        sample = cfl_list_entry(sample_iter, struct cprof_sample, _head);
        TEST_CHECK(sample->value_count == 1);
        if (sample->value_count >= 1 && sample->values != NULL) {
            TEST_CHECK(sample->values[0] == 42);
        }
        TEST_CHECK(sample->location_index_count >= 1 && "sample must have at least one location_index");
        if (sample->location_index_count >= 1 && sample->location_index != NULL) {
            TEST_CHECK(sample->location_index[0] == 0 && "sample must reference first location");
        }
        /* sample must reference a link; decoder may use dict index 0 or 1 (sentinel vs first real link) */
        TEST_CHECK(cfl_list_size(&profile->link_table) > 0 && "profile must have links");
        if ((size_t)sample->link < cfl_list_size(&profile->link_table)) {
            link_iter = profile->link_table.next;
            for (i = 0; i < (size_t)sample->link && link_iter != &profile->link_table; i++) {
                link_iter = link_iter->next;
            }
            if (link_iter != &profile->link_table) {
                link = cfl_list_entry(link_iter, struct cprof_link, _head);
                TEST_CHECK(link->trace_id[0] == 0x01 && link->trace_id[15] == 0x0f &&
                          link->span_id[0] == (uint8_t)0xaa && link->span_id[7] == (uint8_t)0xbb &&
                          "sample must reference link with expected trace_id/span_id");
            }
        }
    }

    /* String table must contain "/bin/app" and "foo" (decoder may reorder) */
    found_bin_app = 0;
    found_foo = 0;
    for (i = 0; i < profile->string_table_count && profile->string_table != NULL; i++) {
        if (profile->string_table[i] != NULL) {
            if (strcmp(profile->string_table[i], "/bin/app") == 0) {
                found_bin_app = 1;
            }
            if (strcmp(profile->string_table[i], "foo") == 0) {
                found_foo = 1;
            }
        }
    }
    TEST_CHECK(found_bin_app && "string_table must contain \"/bin/app\"");
    TEST_CHECK(found_foo && "string_table must contain \"foo\"");
}

/*
 * Encode cprof with dictionary, unpack the wire buffer, and assert the request
 * contains a non-NULL dictionary with expected table counts. Catches encoder
 * regressions (e.g. dictionary no longer emitted).
 */
static void test_wire_format_dictionary_present()
{
    cfl_sds_t                                                                  otlp_result;
    struct cprof                                                              *context;
    int                                                                        result;
    Opentelemetry__Proto__Collector__Profiles__V1development__ExportProfilesServiceRequest *req;

    context = create_cprof_with_dictionary_tables();
    TEST_CHECK(context != NULL);
    if (context == NULL) {
        return;
    }

    result = cprof_encode_opentelemetry_create(&otlp_result, context);
    TEST_CHECK(result == CPROF_ENCODE_OPENTELEMETRY_SUCCESS);
    cprof_destroy(context);
    if (result != CPROF_ENCODE_OPENTELEMETRY_SUCCESS || otlp_result == NULL) {
        return;
    }

    req = opentelemetry__proto__collector__profiles__v1development__export_profiles_service_request__unpack(
            NULL,
            cfl_sds_len(otlp_result),
            (const unsigned char *) otlp_result);

    TEST_CHECK(req != NULL && "unpack of encoded buffer must succeed");
    if (req != NULL) {
        TEST_CHECK(req->dictionary != NULL && "encoded request must contain dictionary");
        if (req->dictionary != NULL) {
            TEST_CHECK(req->dictionary->n_string_table >= 2 && "dictionary must have string table (e.g. \"/bin/app\", \"foo\")");
            TEST_CHECK(req->dictionary->n_mapping_table >= 1 && "dictionary must have at least one mapping");
            TEST_CHECK(req->dictionary->n_function_table >= 1 && "dictionary must have at least one function");
            TEST_CHECK(req->dictionary->n_location_table >= 1 && "dictionary must have at least one location");
            TEST_CHECK(req->dictionary->n_link_table >= 1 && "dictionary must have at least one link");
            TEST_CHECK(req->dictionary->n_stack_table >= 1 && "dictionary must have at least one stack");
        }
        opentelemetry__proto__collector__profiles__v1development__export_profiles_service_request__free_unpacked(req, NULL);
    }

    cprof_encode_opentelemetry_destroy(otlp_result);
}

/* Round-trip cprof with full dictionary tables; decode must succeed and match structure. */
static void test_decoder_dictionary_tables()
{
    cfl_sds_t     otlp_result;
    struct cprof *encoded_context;
    struct cprof *decoded_context;
    int           result;
    size_t        offset;

    encoded_context = create_cprof_with_dictionary_tables();
    TEST_CHECK(encoded_context != NULL);
    if (encoded_context == NULL) {
        return;
    }

    result = cprof_encode_opentelemetry_create(&otlp_result, encoded_context);
    TEST_CHECK(result == CPROF_ENCODE_OPENTELEMETRY_SUCCESS);
    cprof_destroy(encoded_context);
    if (result != CPROF_ENCODE_OPENTELEMETRY_SUCCESS || otlp_result == NULL) {
        return;
    }

    offset = 0;
    decoded_context = NULL;
    result = cprof_decode_opentelemetry_create(&decoded_context,
                                               (unsigned char *) otlp_result,
                                               cfl_sds_len(otlp_result),
                                               &offset);
    TEST_CHECK(result == CPROF_DECODE_OPENTELEMETRY_SUCCESS);

    if (result == CPROF_DECODE_OPENTELEMETRY_SUCCESS && decoded_context != NULL) {
        verify_decoded_cprof_dictionary_tables(decoded_context);
        cprof_decode_opentelemetry_destroy(decoded_context);
    }
    cprof_encode_opentelemetry_destroy(otlp_result);
}

TEST_LIST = {
    {"encoder", test_encoder},
    {"decoder", test_decoder},
    {"encoder_dictionary_tables", test_encoder_dictionary_tables},
    {"wire_format_dictionary_present", test_wire_format_dictionary_present},
    {"decoder_dictionary_tables", test_decoder_dictionary_tables},
    { 0 }
};
