/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: opentelemetry/proto/profiles/v1development/profiles.proto */

#ifndef PROTOBUF_C_opentelemetry_2fproto_2fprofiles_2fv1development_2fprofiles_2eproto__INCLUDED
#define PROTOBUF_C_opentelemetry_2fproto_2fprofiles_2fv1development_2fprofiles_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protobuf-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1005002 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protobuf-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protobuf-c.
#endif

#include "opentelemetry/proto/common/v1/common.pb-c.h"
#include "opentelemetry/proto/resource/v1/resource.pb-c.h"

typedef struct Opentelemetry__Proto__Profiles__V1development__ProfilesDictionary Opentelemetry__Proto__Profiles__V1development__ProfilesDictionary;
typedef struct Opentelemetry__Proto__Profiles__V1development__ProfilesData Opentelemetry__Proto__Profiles__V1development__ProfilesData;
typedef struct Opentelemetry__Proto__Profiles__V1development__ResourceProfiles Opentelemetry__Proto__Profiles__V1development__ResourceProfiles;
typedef struct Opentelemetry__Proto__Profiles__V1development__ScopeProfiles Opentelemetry__Proto__Profiles__V1development__ScopeProfiles;
typedef struct Opentelemetry__Proto__Profiles__V1development__Profile Opentelemetry__Proto__Profiles__V1development__Profile;
typedef struct Opentelemetry__Proto__Profiles__V1development__Link Opentelemetry__Proto__Profiles__V1development__Link;
typedef struct Opentelemetry__Proto__Profiles__V1development__ValueType Opentelemetry__Proto__Profiles__V1development__ValueType;
typedef struct Opentelemetry__Proto__Profiles__V1development__Sample Opentelemetry__Proto__Profiles__V1development__Sample;
typedef struct Opentelemetry__Proto__Profiles__V1development__Mapping Opentelemetry__Proto__Profiles__V1development__Mapping;
typedef struct Opentelemetry__Proto__Profiles__V1development__Stack Opentelemetry__Proto__Profiles__V1development__Stack;
typedef struct Opentelemetry__Proto__Profiles__V1development__Location Opentelemetry__Proto__Profiles__V1development__Location;
typedef struct Opentelemetry__Proto__Profiles__V1development__Line Opentelemetry__Proto__Profiles__V1development__Line;
typedef struct Opentelemetry__Proto__Profiles__V1development__Function Opentelemetry__Proto__Profiles__V1development__Function;
typedef struct Opentelemetry__Proto__Profiles__V1development__KeyValueAndUnit Opentelemetry__Proto__Profiles__V1development__KeyValueAndUnit;


/* --- enums --- */


/* --- messages --- */

/*
 * ProfilesDictionary represents the profiles data shared across the
 * entire message being sent. The following applies to all fields in this
 * message:
 * - A dictionary is an array of dictionary items. Users of the dictionary
 *   compactly reference the items using the index within the array.
 * - A dictionary MUST have a zero value encoded as the first element. This
 *   allows for _index fields pointing into the dictionary to use a 0 pointer
 *   value to indicate 'null' / 'not set'. Unless otherwise defined, a 'zero
 *   value' message value is one with all default field values, so as to
 *   minimize wire encoded size.
 * - There SHOULD NOT be dupes in a dictionary. The identity of dictionary
 *   items is based on their value, recursively as needed. If a particular
 *   implementation does emit duplicated items, it MUST NOT attempt to give them
 *   meaning based on the index or order. A profile processor may remove
 *   duplicate items and this MUST NOT have any observable effects for
 *   consumers.
 * - There SHOULD NOT be orphaned (unreferenced) items in a dictionary. A
 *   profile processor may remove ("garbage-collect") orphaned items and this
 *   MUST NOT have any observable effects for consumers.
 */
struct  Opentelemetry__Proto__Profiles__V1development__ProfilesDictionary
{
  ProtobufCMessage base;
  /*
   * Mappings from address ranges to the image/binary/library mapped
   * into that address range referenced by locations via Location.mapping_index.
   * mapping_table[0] must always be zero value (Mapping{}) and present.
   */
  size_t n_mapping_table;
  Opentelemetry__Proto__Profiles__V1development__Mapping **mapping_table;
  /*
   * Locations referenced by samples via Stack.location_indices.
   * location_table[0] must always be zero value (Location{}) and present.
   */
  size_t n_location_table;
  Opentelemetry__Proto__Profiles__V1development__Location **location_table;
  /*
   * Functions referenced by locations via Line.function_index.
   * function_table[0] must always be zero value (Function{}) and present.
   */
  size_t n_function_table;
  Opentelemetry__Proto__Profiles__V1development__Function **function_table;
  /*
   * Links referenced by samples via Sample.link_index.
   * link_table[0] must always be zero value (Link{}) and present.
   */
  size_t n_link_table;
  Opentelemetry__Proto__Profiles__V1development__Link **link_table;
  /*
   * A common table for strings referenced by various messages.
   * string_table[0] must always be "" and present.
   */
  size_t n_string_table;
  char **string_table;
  /*
   * A common table for attributes referenced by the Profile, Sample, Mapping
   * and Location messages below through attribute_indices field. Each entry is
   * a key/value pair with an optional unit. Since this is a dictionary table,
   * multiple entries with the same key may be present, unlike direct attribute
   * tables like Resource.attributes. The referencing attribute_indices fields,
   * though, do maintain the key uniqueness requirement.
   * It's recommended to use attributes for variables with bounded cardinality,
   * such as categorical variables
   * (https://en.wikipedia.org/wiki/Categorical_variable). Using an attribute of
   * a floating point type (e.g., CPU time) in a sample can quickly make every
   * attribute value unique, defeating the purpose of the dictionary and
   * impractically increasing the profile size.
   * Examples of attributes:
   *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
   *     "abc.com/myattribute": true
   *     "allocation_size": 128 bytes
   * attribute_table[0] must always be zero value (KeyValueAndUnit{}) and present.
   */
  size_t n_attribute_table;
  Opentelemetry__Proto__Profiles__V1development__KeyValueAndUnit **attribute_table;
  /*
   * Stacks referenced by samples via Sample.stack_index.
   * stack_table[0] must always be zero value (Stack{}) and present.
   */
  size_t n_stack_table;
  Opentelemetry__Proto__Profiles__V1development__Stack **stack_table;
};
#define OPENTELEMETRY__PROTO__PROFILES__V1DEVELOPMENT__PROFILES_DICTIONARY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__profiles__v1development__profiles_dictionary__descriptor) \
, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL }


/*
 * ProfilesData represents the profiles data that can be stored in persistent storage,
 * OR can be embedded by other protocols that transfer OTLP profiles data but do not
 * implement the OTLP protocol.
 * The main difference between this message and collector protocol is that
 * in this message there will not be any "control" or "metadata" specific to
 * OTLP protocol.
 * When new fields are added into this message, the OTLP request MUST be updated
 * as well.
 */
struct  Opentelemetry__Proto__Profiles__V1development__ProfilesData
{
  ProtobufCMessage base;
  /*
   * An array of ResourceProfiles.
   * For data coming from an SDK profiler, this array will typically contain one
   * element. Host-level profilers will usually create one ResourceProfile per
   * container, as well as one additional ResourceProfile grouping all samples
   * from non-containerized processes.
   * Other resource groupings are possible as well and clarified via
   * Resource.attributes and semantic conventions.
   * Tools that visualize profiles should prefer displaying
   * resources_profiles[0].scope_profiles[0].profiles[0] by default.
   */
  size_t n_resource_profiles;
  Opentelemetry__Proto__Profiles__V1development__ResourceProfiles **resource_profiles;
  /*
   * One instance of ProfilesDictionary
   */
  Opentelemetry__Proto__Profiles__V1development__ProfilesDictionary *dictionary;
};
#define OPENTELEMETRY__PROTO__PROFILES__V1DEVELOPMENT__PROFILES_DATA__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__profiles__v1development__profiles_data__descriptor) \
, 0,NULL, NULL }


/*
 * A collection of ScopeProfiles from a Resource.
 */
struct  Opentelemetry__Proto__Profiles__V1development__ResourceProfiles
{
  ProtobufCMessage base;
  /*
   * The resource for the profiles in this message.
   * If this field is not set then no resource info is known.
   */
  Opentelemetry__Proto__Resource__V1__Resource *resource;
  /*
   * A list of ScopeProfiles that originate from a resource.
   */
  size_t n_scope_profiles;
  Opentelemetry__Proto__Profiles__V1development__ScopeProfiles **scope_profiles;
  /*
   * The Schema URL, if known. This is the identifier of the Schema that the resource data
   * is recorded in. Notably, the last part of the URL path is the version number of the
   * schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
   * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
   * This schema_url applies to the data in the "resource" field. It does not apply
   * to the data in the "scope_profiles" field which have their own schema_url field.
   */
  char *schema_url;
};
#define OPENTELEMETRY__PROTO__PROFILES__V1DEVELOPMENT__RESOURCE_PROFILES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__profiles__v1development__resource_profiles__descriptor) \
, NULL, 0,NULL, (char *)protobuf_c_empty_string }


/*
 * A collection of Profiles produced by an InstrumentationScope.
 */
struct  Opentelemetry__Proto__Profiles__V1development__ScopeProfiles
{
  ProtobufCMessage base;
  /*
   * The instrumentation scope information for the profiles in this message.
   * Semantically when InstrumentationScope isn't set, it is equivalent with
   * an empty instrumentation scope name (unknown).
   */
  Opentelemetry__Proto__Common__V1__InstrumentationScope *scope;
  /*
   * A list of Profiles that originate from an instrumentation scope.
   */
  size_t n_profiles;
  Opentelemetry__Proto__Profiles__V1development__Profile **profiles;
  /*
   * The Schema URL, if known. This is the identifier of the Schema that the profile data
   * is recorded in. Notably, the last part of the URL path is the version number of the
   * schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
   * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
   * This schema_url applies to the data in the "scope" field and all profiles in the
   * "profiles" field.
   */
  char *schema_url;
};
#define OPENTELEMETRY__PROTO__PROFILES__V1DEVELOPMENT__SCOPE_PROFILES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__profiles__v1development__scope_profiles__descriptor) \
, NULL, 0,NULL, (char *)protobuf_c_empty_string }


/*
 * Represents a complete profile, including sample types, samples, mappings to
 * binaries, stacks, locations, functions, string table, and additional
 * metadata. It modifies and annotates pprof Profile with OpenTelemetry
 * specific fields.
 * Note that whilst fields in this message retain the name and field id from pprof in most cases
 * for ease of understanding data migration, it is not intended that pprof:Profile and
 * OpenTelemetry:Profile encoding be wire compatible.
 */
struct  Opentelemetry__Proto__Profiles__V1development__Profile
{
  ProtobufCMessage base;
  /*
   * The type and unit of all Sample.values in this profile.
   * For a cpu or off-cpu profile this might be:
   *   ["cpu","nanoseconds"] or ["off_cpu","nanoseconds"]
   * For a heap profile, this might be:
   *   ["allocated_objects","count"] or ["allocated_space","bytes"],
   */
  Opentelemetry__Proto__Profiles__V1development__ValueType *sample_type;
  /*
   * The set of samples recorded in this profile.
   */
  size_t n_samples;
  Opentelemetry__Proto__Profiles__V1development__Sample **samples;
  /*
   * Time of collection (UTC) represented as nanoseconds past the epoch.
   */
  uint64_t time_unix_nano;
  /*
   * Duration of the profile, if a duration makes sense.
   */
  uint64_t duration_nano;
  /*
   * The kind of events between sampled occurrences.
   * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
   */
  Opentelemetry__Proto__Profiles__V1development__ValueType *period_type;
  /*
   * The number of events between sampled occurrences.
   */
  int64_t period;
  /*
   * A globally unique identifier for a profile. The ID is a 16-byte array. An ID with
   * all zeroes is considered invalid. It may be used for deduplication and signal
   * correlation purposes. It is acceptable to treat two profiles with different values
   * in this field as not equal, even if they represented the same object at an earlier
   * time.
   * This field is optional; an ID may be assigned to an ID-less profile in a later step.
   */
  ProtobufCBinaryData profile_id;
  /*
   * The number of attributes that were discarded. Attributes
   * can be discarded because their keys are too long or because there are too many
   * attributes. If this value is 0, then no attributes were dropped.
   */
  uint32_t dropped_attributes_count;
  /*
   * The original payload format. See also original_payload. Optional, but the
   * format and the bytes must be set or unset together.
   * The allowed values for the format string are defined by the OpenTelemetry
   * specification. Some examples are "jfr", "pprof", "linux_perf".
   * The original payload may be optionally provided when the conversion to the
   * OLTP format was done from a different format with some loss of the fidelity
   * and the receiver may want to store the original payload to allow future
   * lossless export or reinterpretation. Some examples of the original format
   * are JFR (Java Flight Recorder), pprof, Linux perf.
   * Even when the original payload is in a format that is semantically close to
   * OTLP, such as pprof, a conversion may still be lossy in some cases (e.g. if
   * the pprof file contains custom extensions or conventions).
   * The original payload can be large in size, so including the original
   * payload should be configurable by the profiler or collector options. The
   * default behavior should be to not include the original payload.
   */
  char *original_payload_format;
  /*
   * The original payload bytes. See also original_payload_format. Optional, but
   * format and the bytes must be set or unset together.
   */
  ProtobufCBinaryData original_payload;
  /*
   * References to attributes in attribute_table. [optional]
   */
  size_t n_attribute_indices;
  int32_t *attribute_indices;
};
#define OPENTELEMETRY__PROTO__PROFILES__V1DEVELOPMENT__PROFILE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__profiles__v1development__profile__descriptor) \
, NULL, 0,NULL, 0, 0, NULL, 0, {0,NULL}, 0, (char *)protobuf_c_empty_string, {0,NULL}, 0,NULL }


/*
 * A pointer from a profile Sample to a trace Span.
 * Connects a profile sample to a trace span, identified by unique trace and span IDs.
 */
struct  Opentelemetry__Proto__Profiles__V1development__Link
{
  ProtobufCMessage base;
  /*
   * A unique identifier of a trace that this linked span is part of. The ID is a
   * 16-byte array.
   */
  ProtobufCBinaryData trace_id;
  /*
   * A unique identifier for the linked span. The ID is an 8-byte array.
   */
  ProtobufCBinaryData span_id;
};
#define OPENTELEMETRY__PROTO__PROFILES__V1DEVELOPMENT__LINK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__profiles__v1development__link__descriptor) \
, {0,NULL}, {0,NULL} }


/*
 * ValueType describes the type and units of a value.
 */
struct  Opentelemetry__Proto__Profiles__V1development__ValueType
{
  ProtobufCMessage base;
  /*
   * Index into ProfilesDictionary.string_table.
   */
  int32_t type_strindex;
  /*
   * Index into ProfilesDictionary.string_table.
   */
  int32_t unit_strindex;
};
#define OPENTELEMETRY__PROTO__PROFILES__V1DEVELOPMENT__VALUE_TYPE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__profiles__v1development__value_type__descriptor) \
, 0, 0 }


/*
 * Each Sample records values encountered in some program context. The program
 * context is typically a stack trace, perhaps augmented with auxiliary
 * information like the thread-id, some indicator of a higher level request
 * being handled etc.
 * A Sample MUST have have at least one values or timestamps_unix_nano entry. If
 * both fields are populated, they MUST contain the same number of elements, and
 * the elements at the same index MUST refer to the same event.
 * Examples of different ways of representing a sample with the total value of 10:
 * Report of a stacktrace at 10 timestamps (consumers must assume the value is 1 for each point):
 *    values: []
 *    timestamps_unix_nano: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 * Report of a stacktrace with an aggregated value without timestamps:
 *   values: [10]
 *    timestamps_unix_nano: []
 * Report of a stacktrace at 4 timestamps where each point records a specific value:
 *    values: [2, 2, 3, 3]
 *    timestamps_unix_nano: [1, 2, 3, 4]
 */
struct  Opentelemetry__Proto__Profiles__V1development__Sample
{
  ProtobufCMessage base;
  /*
   * Reference to stack in ProfilesDictionary.stack_table.
   */
  int32_t stack_index;
  /*
   * The type and unit of each value is defined by Profile.sample_type.
   */
  size_t n_values;
  int64_t *values;
  /*
   * References to attributes in ProfilesDictionary.attribute_table. [optional]
   */
  size_t n_attribute_indices;
  int32_t *attribute_indices;
  /*
   * Reference to link in ProfilesDictionary.link_table. [optional]
   * It can be unset / set to 0 if no link exists, as link_table[0] is always a 'null' default value.
   */
  int32_t link_index;
  /*
   * Timestamps associated with Sample represented in nanoseconds. These
   * timestamps should fall within the Profile's time range.
   */
  size_t n_timestamps_unix_nano;
  uint64_t *timestamps_unix_nano;
};
#define OPENTELEMETRY__PROTO__PROFILES__V1DEVELOPMENT__SAMPLE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__profiles__v1development__sample__descriptor) \
, 0, 0,NULL, 0,NULL, 0, 0,NULL }


/*
 * Describes the mapping of a binary in memory, including its address range,
 * file offset, and metadata like build ID
 */
struct  Opentelemetry__Proto__Profiles__V1development__Mapping
{
  ProtobufCMessage base;
  /*
   * Address at which the binary (or DLL) is loaded into memory.
   */
  uint64_t memory_start;
  /*
   * The limit of the address range occupied by this mapping.
   */
  uint64_t memory_limit;
  /*
   * Offset in the binary that corresponds to the first mapped address.
   */
  uint64_t file_offset;
  /*
   * The object this entry is loaded from.  This can be a filename on
   * disk for the main binary and shared libraries, or virtual
   * abstractions like "[vdso]".
   */
  /*
   * Index into ProfilesDictionary.string_table.
   */
  int32_t filename_strindex;
  /*
   * References to attributes in ProfilesDictionary.attribute_table. [optional]
   */
  size_t n_attribute_indices;
  int32_t *attribute_indices;
};
#define OPENTELEMETRY__PROTO__PROFILES__V1DEVELOPMENT__MAPPING__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__profiles__v1development__mapping__descriptor) \
, 0, 0, 0, 0, 0,NULL }


/*
 * A Stack represents a stack trace as a list of locations.
 */
struct  Opentelemetry__Proto__Profiles__V1development__Stack
{
  ProtobufCMessage base;
  /*
   * References to locations in ProfilesDictionary.location_table.
   * The first location is the leaf frame.
   */
  size_t n_location_indices;
  int32_t *location_indices;
};
#define OPENTELEMETRY__PROTO__PROFILES__V1DEVELOPMENT__STACK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__profiles__v1development__stack__descriptor) \
, 0,NULL }


/*
 * Describes function and line table debug information.
 */
struct  Opentelemetry__Proto__Profiles__V1development__Location
{
  ProtobufCMessage base;
  /*
   * Reference to mapping in ProfilesDictionary.mapping_table.
   * It can be unset / set to 0 if the mapping is unknown or not applicable for
   * this profile type, as mapping_table[0] is always a 'null' default mapping.
   */
  int32_t mapping_index;
  /*
   * The instruction address for this location, if available.  It
   * should be within [Mapping.memory_start...Mapping.memory_limit]
   * for the corresponding mapping. A non-leaf address may be in the
   * middle of a call instruction. It is up to display tools to find
   * the beginning of the instruction if necessary.
   */
  uint64_t address;
  /*
   * Multiple line indicates this location has inlined functions,
   * where the last entry represents the caller into which the
   * preceding entries were inlined.
   * E.g., if memcpy() is inlined into printf:
   *    lines[0].function_name == "memcpy"
   *    lines[1].function_name == "printf"
   */
  size_t n_lines;
  Opentelemetry__Proto__Profiles__V1development__Line **lines;
  /*
   * References to attributes in ProfilesDictionary.attribute_table. [optional]
   */
  size_t n_attribute_indices;
  int32_t *attribute_indices;
};
#define OPENTELEMETRY__PROTO__PROFILES__V1DEVELOPMENT__LOCATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__profiles__v1development__location__descriptor) \
, 0, 0, 0,NULL, 0,NULL }


/*
 * Details a specific line in a source code, linked to a function.
 */
struct  Opentelemetry__Proto__Profiles__V1development__Line
{
  ProtobufCMessage base;
  /*
   * Reference to function in ProfilesDictionary.function_table.
   */
  int32_t function_index;
  /*
   * Line number in source code. 0 means unset.
   */
  int64_t line;
  /*
   * Column number in source code. 0 means unset.
   */
  int64_t column;
};
#define OPENTELEMETRY__PROTO__PROFILES__V1DEVELOPMENT__LINE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__profiles__v1development__line__descriptor) \
, 0, 0, 0 }


/*
 * Describes a function, including its human-readable name, system name,
 * source file, and starting line number in the source.
 */
struct  Opentelemetry__Proto__Profiles__V1development__Function
{
  ProtobufCMessage base;
  /*
   * The function name. Empty string if not available.
   */
  int32_t name_strindex;
  /*
   * Function name, as identified by the system. For instance,
   * it can be a C++ mangled name. Empty string if not available.
   */
  int32_t system_name_strindex;
  /*
   * Source file containing the function. Empty string if not available.
   */
  int32_t filename_strindex;
  /*
   * Line number in source file. 0 means unset.
   */
  int64_t start_line;
};
#define OPENTELEMETRY__PROTO__PROFILES__V1DEVELOPMENT__FUNCTION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__profiles__v1development__function__descriptor) \
, 0, 0, 0, 0 }


/*
 * A custom 'dictionary native' style of encoding attributes which is more convenient
 * for profiles than opentelemetry.proto.common.v1.KeyValue
 * Specifically, uses the string table for keys and allows optional unit information.
 */
struct  Opentelemetry__Proto__Profiles__V1development__KeyValueAndUnit
{
  ProtobufCMessage base;
  /*
   * The index into the string table for the attribute's key.
   */
  int32_t key_strindex;
  /*
   * The value of the attribute.
   */
  Opentelemetry__Proto__Common__V1__AnyValue *value;
  /*
   * The index into the string table for the attribute's unit.
   * zero indicates implicit (by semconv) or non-defined unit.
   */
  int32_t unit_strindex;
};
#define OPENTELEMETRY__PROTO__PROFILES__V1DEVELOPMENT__KEY_VALUE_AND_UNIT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__profiles__v1development__key_value_and_unit__descriptor) \
, 0, NULL, 0 }


/* Opentelemetry__Proto__Profiles__V1development__ProfilesDictionary methods */
void   opentelemetry__proto__profiles__v1development__profiles_dictionary__init
                     (Opentelemetry__Proto__Profiles__V1development__ProfilesDictionary         *message);
size_t opentelemetry__proto__profiles__v1development__profiles_dictionary__get_packed_size
                     (const Opentelemetry__Proto__Profiles__V1development__ProfilesDictionary   *message);
size_t opentelemetry__proto__profiles__v1development__profiles_dictionary__pack
                     (const Opentelemetry__Proto__Profiles__V1development__ProfilesDictionary   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__profiles__v1development__profiles_dictionary__pack_to_buffer
                     (const Opentelemetry__Proto__Profiles__V1development__ProfilesDictionary   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Profiles__V1development__ProfilesDictionary *
       opentelemetry__proto__profiles__v1development__profiles_dictionary__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__profiles__v1development__profiles_dictionary__free_unpacked
                     (Opentelemetry__Proto__Profiles__V1development__ProfilesDictionary *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Profiles__V1development__ProfilesData methods */
void   opentelemetry__proto__profiles__v1development__profiles_data__init
                     (Opentelemetry__Proto__Profiles__V1development__ProfilesData         *message);
size_t opentelemetry__proto__profiles__v1development__profiles_data__get_packed_size
                     (const Opentelemetry__Proto__Profiles__V1development__ProfilesData   *message);
size_t opentelemetry__proto__profiles__v1development__profiles_data__pack
                     (const Opentelemetry__Proto__Profiles__V1development__ProfilesData   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__profiles__v1development__profiles_data__pack_to_buffer
                     (const Opentelemetry__Proto__Profiles__V1development__ProfilesData   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Profiles__V1development__ProfilesData *
       opentelemetry__proto__profiles__v1development__profiles_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__profiles__v1development__profiles_data__free_unpacked
                     (Opentelemetry__Proto__Profiles__V1development__ProfilesData *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Profiles__V1development__ResourceProfiles methods */
void   opentelemetry__proto__profiles__v1development__resource_profiles__init
                     (Opentelemetry__Proto__Profiles__V1development__ResourceProfiles         *message);
size_t opentelemetry__proto__profiles__v1development__resource_profiles__get_packed_size
                     (const Opentelemetry__Proto__Profiles__V1development__ResourceProfiles   *message);
size_t opentelemetry__proto__profiles__v1development__resource_profiles__pack
                     (const Opentelemetry__Proto__Profiles__V1development__ResourceProfiles   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__profiles__v1development__resource_profiles__pack_to_buffer
                     (const Opentelemetry__Proto__Profiles__V1development__ResourceProfiles   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Profiles__V1development__ResourceProfiles *
       opentelemetry__proto__profiles__v1development__resource_profiles__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__profiles__v1development__resource_profiles__free_unpacked
                     (Opentelemetry__Proto__Profiles__V1development__ResourceProfiles *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Profiles__V1development__ScopeProfiles methods */
void   opentelemetry__proto__profiles__v1development__scope_profiles__init
                     (Opentelemetry__Proto__Profiles__V1development__ScopeProfiles         *message);
size_t opentelemetry__proto__profiles__v1development__scope_profiles__get_packed_size
                     (const Opentelemetry__Proto__Profiles__V1development__ScopeProfiles   *message);
size_t opentelemetry__proto__profiles__v1development__scope_profiles__pack
                     (const Opentelemetry__Proto__Profiles__V1development__ScopeProfiles   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__profiles__v1development__scope_profiles__pack_to_buffer
                     (const Opentelemetry__Proto__Profiles__V1development__ScopeProfiles   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Profiles__V1development__ScopeProfiles *
       opentelemetry__proto__profiles__v1development__scope_profiles__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__profiles__v1development__scope_profiles__free_unpacked
                     (Opentelemetry__Proto__Profiles__V1development__ScopeProfiles *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Profiles__V1development__Profile methods */
void   opentelemetry__proto__profiles__v1development__profile__init
                     (Opentelemetry__Proto__Profiles__V1development__Profile         *message);
size_t opentelemetry__proto__profiles__v1development__profile__get_packed_size
                     (const Opentelemetry__Proto__Profiles__V1development__Profile   *message);
size_t opentelemetry__proto__profiles__v1development__profile__pack
                     (const Opentelemetry__Proto__Profiles__V1development__Profile   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__profiles__v1development__profile__pack_to_buffer
                     (const Opentelemetry__Proto__Profiles__V1development__Profile   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Profiles__V1development__Profile *
       opentelemetry__proto__profiles__v1development__profile__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__profiles__v1development__profile__free_unpacked
                     (Opentelemetry__Proto__Profiles__V1development__Profile *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Profiles__V1development__Link methods */
void   opentelemetry__proto__profiles__v1development__link__init
                     (Opentelemetry__Proto__Profiles__V1development__Link         *message);
size_t opentelemetry__proto__profiles__v1development__link__get_packed_size
                     (const Opentelemetry__Proto__Profiles__V1development__Link   *message);
size_t opentelemetry__proto__profiles__v1development__link__pack
                     (const Opentelemetry__Proto__Profiles__V1development__Link   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__profiles__v1development__link__pack_to_buffer
                     (const Opentelemetry__Proto__Profiles__V1development__Link   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Profiles__V1development__Link *
       opentelemetry__proto__profiles__v1development__link__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__profiles__v1development__link__free_unpacked
                     (Opentelemetry__Proto__Profiles__V1development__Link *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Profiles__V1development__ValueType methods */
void   opentelemetry__proto__profiles__v1development__value_type__init
                     (Opentelemetry__Proto__Profiles__V1development__ValueType         *message);
size_t opentelemetry__proto__profiles__v1development__value_type__get_packed_size
                     (const Opentelemetry__Proto__Profiles__V1development__ValueType   *message);
size_t opentelemetry__proto__profiles__v1development__value_type__pack
                     (const Opentelemetry__Proto__Profiles__V1development__ValueType   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__profiles__v1development__value_type__pack_to_buffer
                     (const Opentelemetry__Proto__Profiles__V1development__ValueType   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Profiles__V1development__ValueType *
       opentelemetry__proto__profiles__v1development__value_type__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__profiles__v1development__value_type__free_unpacked
                     (Opentelemetry__Proto__Profiles__V1development__ValueType *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Profiles__V1development__Sample methods */
void   opentelemetry__proto__profiles__v1development__sample__init
                     (Opentelemetry__Proto__Profiles__V1development__Sample         *message);
size_t opentelemetry__proto__profiles__v1development__sample__get_packed_size
                     (const Opentelemetry__Proto__Profiles__V1development__Sample   *message);
size_t opentelemetry__proto__profiles__v1development__sample__pack
                     (const Opentelemetry__Proto__Profiles__V1development__Sample   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__profiles__v1development__sample__pack_to_buffer
                     (const Opentelemetry__Proto__Profiles__V1development__Sample   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Profiles__V1development__Sample *
       opentelemetry__proto__profiles__v1development__sample__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__profiles__v1development__sample__free_unpacked
                     (Opentelemetry__Proto__Profiles__V1development__Sample *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Profiles__V1development__Mapping methods */
void   opentelemetry__proto__profiles__v1development__mapping__init
                     (Opentelemetry__Proto__Profiles__V1development__Mapping         *message);
size_t opentelemetry__proto__profiles__v1development__mapping__get_packed_size
                     (const Opentelemetry__Proto__Profiles__V1development__Mapping   *message);
size_t opentelemetry__proto__profiles__v1development__mapping__pack
                     (const Opentelemetry__Proto__Profiles__V1development__Mapping   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__profiles__v1development__mapping__pack_to_buffer
                     (const Opentelemetry__Proto__Profiles__V1development__Mapping   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Profiles__V1development__Mapping *
       opentelemetry__proto__profiles__v1development__mapping__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__profiles__v1development__mapping__free_unpacked
                     (Opentelemetry__Proto__Profiles__V1development__Mapping *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Profiles__V1development__Stack methods */
void   opentelemetry__proto__profiles__v1development__stack__init
                     (Opentelemetry__Proto__Profiles__V1development__Stack         *message);
size_t opentelemetry__proto__profiles__v1development__stack__get_packed_size
                     (const Opentelemetry__Proto__Profiles__V1development__Stack   *message);
size_t opentelemetry__proto__profiles__v1development__stack__pack
                     (const Opentelemetry__Proto__Profiles__V1development__Stack   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__profiles__v1development__stack__pack_to_buffer
                     (const Opentelemetry__Proto__Profiles__V1development__Stack   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Profiles__V1development__Stack *
       opentelemetry__proto__profiles__v1development__stack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__profiles__v1development__stack__free_unpacked
                     (Opentelemetry__Proto__Profiles__V1development__Stack *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Profiles__V1development__Location methods */
void   opentelemetry__proto__profiles__v1development__location__init
                     (Opentelemetry__Proto__Profiles__V1development__Location         *message);
size_t opentelemetry__proto__profiles__v1development__location__get_packed_size
                     (const Opentelemetry__Proto__Profiles__V1development__Location   *message);
size_t opentelemetry__proto__profiles__v1development__location__pack
                     (const Opentelemetry__Proto__Profiles__V1development__Location   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__profiles__v1development__location__pack_to_buffer
                     (const Opentelemetry__Proto__Profiles__V1development__Location   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Profiles__V1development__Location *
       opentelemetry__proto__profiles__v1development__location__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__profiles__v1development__location__free_unpacked
                     (Opentelemetry__Proto__Profiles__V1development__Location *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Profiles__V1development__Line methods */
void   opentelemetry__proto__profiles__v1development__line__init
                     (Opentelemetry__Proto__Profiles__V1development__Line         *message);
size_t opentelemetry__proto__profiles__v1development__line__get_packed_size
                     (const Opentelemetry__Proto__Profiles__V1development__Line   *message);
size_t opentelemetry__proto__profiles__v1development__line__pack
                     (const Opentelemetry__Proto__Profiles__V1development__Line   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__profiles__v1development__line__pack_to_buffer
                     (const Opentelemetry__Proto__Profiles__V1development__Line   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Profiles__V1development__Line *
       opentelemetry__proto__profiles__v1development__line__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__profiles__v1development__line__free_unpacked
                     (Opentelemetry__Proto__Profiles__V1development__Line *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Profiles__V1development__Function methods */
void   opentelemetry__proto__profiles__v1development__function__init
                     (Opentelemetry__Proto__Profiles__V1development__Function         *message);
size_t opentelemetry__proto__profiles__v1development__function__get_packed_size
                     (const Opentelemetry__Proto__Profiles__V1development__Function   *message);
size_t opentelemetry__proto__profiles__v1development__function__pack
                     (const Opentelemetry__Proto__Profiles__V1development__Function   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__profiles__v1development__function__pack_to_buffer
                     (const Opentelemetry__Proto__Profiles__V1development__Function   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Profiles__V1development__Function *
       opentelemetry__proto__profiles__v1development__function__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__profiles__v1development__function__free_unpacked
                     (Opentelemetry__Proto__Profiles__V1development__Function *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Profiles__V1development__KeyValueAndUnit methods */
void   opentelemetry__proto__profiles__v1development__key_value_and_unit__init
                     (Opentelemetry__Proto__Profiles__V1development__KeyValueAndUnit         *message);
size_t opentelemetry__proto__profiles__v1development__key_value_and_unit__get_packed_size
                     (const Opentelemetry__Proto__Profiles__V1development__KeyValueAndUnit   *message);
size_t opentelemetry__proto__profiles__v1development__key_value_and_unit__pack
                     (const Opentelemetry__Proto__Profiles__V1development__KeyValueAndUnit   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__profiles__v1development__key_value_and_unit__pack_to_buffer
                     (const Opentelemetry__Proto__Profiles__V1development__KeyValueAndUnit   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Profiles__V1development__KeyValueAndUnit *
       opentelemetry__proto__profiles__v1development__key_value_and_unit__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__profiles__v1development__key_value_and_unit__free_unpacked
                     (Opentelemetry__Proto__Profiles__V1development__KeyValueAndUnit *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Opentelemetry__Proto__Profiles__V1development__ProfilesDictionary_Closure)
                 (const Opentelemetry__Proto__Profiles__V1development__ProfilesDictionary *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Profiles__V1development__ProfilesData_Closure)
                 (const Opentelemetry__Proto__Profiles__V1development__ProfilesData *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Profiles__V1development__ResourceProfiles_Closure)
                 (const Opentelemetry__Proto__Profiles__V1development__ResourceProfiles *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Profiles__V1development__ScopeProfiles_Closure)
                 (const Opentelemetry__Proto__Profiles__V1development__ScopeProfiles *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Profiles__V1development__Profile_Closure)
                 (const Opentelemetry__Proto__Profiles__V1development__Profile *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Profiles__V1development__Link_Closure)
                 (const Opentelemetry__Proto__Profiles__V1development__Link *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Profiles__V1development__ValueType_Closure)
                 (const Opentelemetry__Proto__Profiles__V1development__ValueType *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Profiles__V1development__Sample_Closure)
                 (const Opentelemetry__Proto__Profiles__V1development__Sample *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Profiles__V1development__Mapping_Closure)
                 (const Opentelemetry__Proto__Profiles__V1development__Mapping *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Profiles__V1development__Stack_Closure)
                 (const Opentelemetry__Proto__Profiles__V1development__Stack *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Profiles__V1development__Location_Closure)
                 (const Opentelemetry__Proto__Profiles__V1development__Location *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Profiles__V1development__Line_Closure)
                 (const Opentelemetry__Proto__Profiles__V1development__Line *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Profiles__V1development__Function_Closure)
                 (const Opentelemetry__Proto__Profiles__V1development__Function *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Profiles__V1development__KeyValueAndUnit_Closure)
                 (const Opentelemetry__Proto__Profiles__V1development__KeyValueAndUnit *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor opentelemetry__proto__profiles__v1development__profiles_dictionary__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__profiles__v1development__profiles_data__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__profiles__v1development__resource_profiles__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__profiles__v1development__scope_profiles__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__profiles__v1development__profile__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__profiles__v1development__link__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__profiles__v1development__value_type__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__profiles__v1development__sample__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__profiles__v1development__mapping__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__profiles__v1development__stack__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__profiles__v1development__location__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__profiles__v1development__line__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__profiles__v1development__function__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__profiles__v1development__key_value_and_unit__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_opentelemetry_2fproto_2fprofiles_2fv1development_2fprofiles_2eproto__INCLUDED */
