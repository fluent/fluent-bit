/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: opentelemetry/proto/metrics/v1/metrics.proto */

#ifndef PROTOBUF_C_opentelemetry_2fproto_2fmetrics_2fv1_2fmetrics_2eproto__INCLUDED
#define PROTOBUF_C_opentelemetry_2fproto_2fmetrics_2fv1_2fmetrics_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protobuf-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1005002 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protobuf-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protobuf-c.
#endif

#include "opentelemetry/proto/common/v1/common.pb-c.h"
#include "opentelemetry/proto/resource/v1/resource.pb-c.h"

typedef struct Opentelemetry__Proto__Metrics__V1__MetricsData Opentelemetry__Proto__Metrics__V1__MetricsData;
typedef struct Opentelemetry__Proto__Metrics__V1__ResourceMetrics Opentelemetry__Proto__Metrics__V1__ResourceMetrics;
typedef struct Opentelemetry__Proto__Metrics__V1__ScopeMetrics Opentelemetry__Proto__Metrics__V1__ScopeMetrics;
typedef struct Opentelemetry__Proto__Metrics__V1__Metric Opentelemetry__Proto__Metrics__V1__Metric;
typedef struct Opentelemetry__Proto__Metrics__V1__Gauge Opentelemetry__Proto__Metrics__V1__Gauge;
typedef struct Opentelemetry__Proto__Metrics__V1__Sum Opentelemetry__Proto__Metrics__V1__Sum;
typedef struct Opentelemetry__Proto__Metrics__V1__Histogram Opentelemetry__Proto__Metrics__V1__Histogram;
typedef struct Opentelemetry__Proto__Metrics__V1__ExponentialHistogram Opentelemetry__Proto__Metrics__V1__ExponentialHistogram;
typedef struct Opentelemetry__Proto__Metrics__V1__Summary Opentelemetry__Proto__Metrics__V1__Summary;
typedef struct Opentelemetry__Proto__Metrics__V1__NumberDataPoint Opentelemetry__Proto__Metrics__V1__NumberDataPoint;
typedef struct Opentelemetry__Proto__Metrics__V1__HistogramDataPoint Opentelemetry__Proto__Metrics__V1__HistogramDataPoint;
typedef struct Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint;
typedef struct Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint__Buckets Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint__Buckets;
typedef struct Opentelemetry__Proto__Metrics__V1__SummaryDataPoint Opentelemetry__Proto__Metrics__V1__SummaryDataPoint;
typedef struct Opentelemetry__Proto__Metrics__V1__SummaryDataPoint__ValueAtQuantile Opentelemetry__Proto__Metrics__V1__SummaryDataPoint__ValueAtQuantile;
typedef struct Opentelemetry__Proto__Metrics__V1__Exemplar Opentelemetry__Proto__Metrics__V1__Exemplar;


/* --- enums --- */

/*
 * AggregationTemporality defines how a metric aggregator reports aggregated
 * values. It describes how those values relate to the time interval over
 * which they are aggregated.
 */
typedef enum _Opentelemetry__Proto__Metrics__V1__AggregationTemporality {
  /*
   * UNSPECIFIED is the default AggregationTemporality, it MUST not be used.
   */
  OPENTELEMETRY__PROTO__METRICS__V1__AGGREGATION_TEMPORALITY__AGGREGATION_TEMPORALITY_UNSPECIFIED = 0,
  /*
   * DELTA is an AggregationTemporality for a metric aggregator which reports
   * changes since last report time. Successive metrics contain aggregation of
   * values from continuous and non-overlapping intervals.
   * The values for a DELTA metric are based only on the time interval
   * associated with one measurement cycle. There is no dependency on
   * previous measurements like is the case for CUMULATIVE metrics.
   * For example, consider a system measuring the number of requests that
   * it receives and reports the sum of these requests every second as a
   * DELTA metric:
   *   1. The system starts receiving at time=t_0.
   *   2. A request is received, the system measures 1 request.
   *   3. A request is received, the system measures 1 request.
   *   4. A request is received, the system measures 1 request.
   *   5. The 1 second collection cycle ends. A metric is exported for the
   *      number of requests received over the interval of time t_0 to
   *      t_0+1 with a value of 3.
   *   6. A request is received, the system measures 1 request.
   *   7. A request is received, the system measures 1 request.
   *   8. The 1 second collection cycle ends. A metric is exported for the
   *      number of requests received over the interval of time t_0+1 to
   *      t_0+2 with a value of 2.
   */
  OPENTELEMETRY__PROTO__METRICS__V1__AGGREGATION_TEMPORALITY__AGGREGATION_TEMPORALITY_DELTA = 1,
  /*
   * CUMULATIVE is an AggregationTemporality for a metric aggregator which
   * reports changes since a fixed start time. This means that current values
   * of a CUMULATIVE metric depend on all previous measurements since the
   * start time. Because of this, the sender is required to retain this state
   * in some form. If this state is lost or invalidated, the CUMULATIVE metric
   * values MUST be reset and a new fixed start time following the last
   * reported measurement time sent MUST be used.
   * For example, consider a system measuring the number of requests that
   * it receives and reports the sum of these requests every second as a
   * CUMULATIVE metric:
   *   1. The system starts receiving at time=t_0.
   *   2. A request is received, the system measures 1 request.
   *   3. A request is received, the system measures 1 request.
   *   4. A request is received, the system measures 1 request.
   *   5. The 1 second collection cycle ends. A metric is exported for the
   *      number of requests received over the interval of time t_0 to
   *      t_0+1 with a value of 3.
   *   6. A request is received, the system measures 1 request.
   *   7. A request is received, the system measures 1 request.
   *   8. The 1 second collection cycle ends. A metric is exported for the
   *      number of requests received over the interval of time t_0 to
   *      t_0+2 with a value of 5.
   *   9. The system experiences a fault and loses state.
   *   10. The system recovers and resumes receiving at time=t_1.
   *   11. A request is received, the system measures 1 request.
   *   12. The 1 second collection cycle ends. A metric is exported for the
   *      number of requests received over the interval of time t_1 to
   *      t_0+1 with a value of 1.
   * Note: Even though, when reporting changes since last report time, using
   * CUMULATIVE is valid, it is not recommended. This may cause problems for
   * systems that do not use start_time to determine when the aggregation
   * value was reset (e.g. Prometheus).
   */
  OPENTELEMETRY__PROTO__METRICS__V1__AGGREGATION_TEMPORALITY__AGGREGATION_TEMPORALITY_CUMULATIVE = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(OPENTELEMETRY__PROTO__METRICS__V1__AGGREGATION_TEMPORALITY)
} Opentelemetry__Proto__Metrics__V1__AggregationTemporality;
/*
 * DataPointFlags is defined as a protobuf 'uint32' type and is to be used as a
 * bit-field representing 32 distinct boolean flags.  Each flag defined in this
 * enum is a bit-mask.  To test the presence of a single flag in the flags of
 * a data point, for example, use an expression like:
 *   (point.flags & DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK) == DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK
 */
typedef enum _Opentelemetry__Proto__Metrics__V1__DataPointFlags {
  /*
   * The zero value for the enum. Should not be used for comparisons.
   * Instead use bitwise "and" with the appropriate mask as shown above.
   */
  OPENTELEMETRY__PROTO__METRICS__V1__DATA_POINT_FLAGS__DATA_POINT_FLAGS_DO_NOT_USE = 0,
  /*
   * This DataPoint is valid but has no recorded value.  This value
   * SHOULD be used to reflect explicitly missing data in a series, as
   * for an equivalent to the Prometheus "staleness marker".
   */
  OPENTELEMETRY__PROTO__METRICS__V1__DATA_POINT_FLAGS__DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(OPENTELEMETRY__PROTO__METRICS__V1__DATA_POINT_FLAGS)
} Opentelemetry__Proto__Metrics__V1__DataPointFlags;

/* --- messages --- */

/*
 * MetricsData represents the metrics data that can be stored in a persistent
 * storage, OR can be embedded by other protocols that transfer OTLP metrics
 * data but do not implement the OTLP protocol.
 * MetricsData
 * └─── ResourceMetrics
 *   ├── Resource
 *   ├── SchemaURL
 *   └── ScopeMetrics
 *      ├── Scope
 *      ├── SchemaURL
 *      └── Metric
 *         ├── Name
 *         ├── Description
 *         ├── Unit
 *         └── data
 *            ├── Gauge
 *            ├── Sum
 *            ├── Histogram
 *            ├── ExponentialHistogram
 *            └── Summary
 * The main difference between this message and collector protocol is that
 * in this message there will not be any "control" or "metadata" specific to
 * OTLP protocol.
 * When new fields are added into this message, the OTLP request MUST be updated
 * as well.
 */
struct  Opentelemetry__Proto__Metrics__V1__MetricsData
{
  ProtobufCMessage base;
  /*
   * An array of ResourceMetrics.
   * For data coming from a single resource this array will typically contain
   * one element. Intermediary nodes that receive data from multiple origins
   * typically batch the data before forwarding further and in that case this
   * array will contain multiple elements.
   */
  size_t n_resource_metrics;
  Opentelemetry__Proto__Metrics__V1__ResourceMetrics **resource_metrics;
};
#define OPENTELEMETRY__PROTO__METRICS__V1__METRICS_DATA__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__metrics_data__descriptor) \
, 0,NULL }


/*
 * A collection of ScopeMetrics from a Resource.
 */
struct  Opentelemetry__Proto__Metrics__V1__ResourceMetrics
{
  ProtobufCMessage base;
  /*
   * The resource for the metrics in this message.
   * If this field is not set then no resource info is known.
   */
  Opentelemetry__Proto__Resource__V1__Resource *resource;
  /*
   * A list of metrics that originate from a resource.
   */
  size_t n_scope_metrics;
  Opentelemetry__Proto__Metrics__V1__ScopeMetrics **scope_metrics;
  /*
   * The Schema URL, if known. This is the identifier of the Schema that the resource data
   * is recorded in. Notably, the last part of the URL path is the version number of the
   * schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
   * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
   * This schema_url applies to the data in the "resource" field. It does not apply
   * to the data in the "scope_metrics" field which have their own schema_url field.
   */
  char *schema_url;
};
#define OPENTELEMETRY__PROTO__METRICS__V1__RESOURCE_METRICS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__resource_metrics__descriptor) \
, NULL, 0,NULL, (char *)protobuf_c_empty_string }


/*
 * A collection of Metrics produced by an Scope.
 */
struct  Opentelemetry__Proto__Metrics__V1__ScopeMetrics
{
  ProtobufCMessage base;
  /*
   * The instrumentation scope information for the metrics in this message.
   * Semantically when InstrumentationScope isn't set, it is equivalent with
   * an empty instrumentation scope name (unknown).
   */
  Opentelemetry__Proto__Common__V1__InstrumentationScope *scope;
  /*
   * A list of metrics that originate from an instrumentation library.
   */
  size_t n_metrics;
  Opentelemetry__Proto__Metrics__V1__Metric **metrics;
  /*
   * The Schema URL, if known. This is the identifier of the Schema that the metric data
   * is recorded in. Notably, the last part of the URL path is the version number of the
   * schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
   * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
   * This schema_url applies to the data in the "scope" field and all metrics in the
   * "metrics" field.
   */
  char *schema_url;
};
#define OPENTELEMETRY__PROTO__METRICS__V1__SCOPE_METRICS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__scope_metrics__descriptor) \
, NULL, 0,NULL, (char *)protobuf_c_empty_string }


typedef enum {
  OPENTELEMETRY__PROTO__METRICS__V1__METRIC__DATA__NOT_SET = 0,
  OPENTELEMETRY__PROTO__METRICS__V1__METRIC__DATA_GAUGE = 5,
  OPENTELEMETRY__PROTO__METRICS__V1__METRIC__DATA_SUM = 7,
  OPENTELEMETRY__PROTO__METRICS__V1__METRIC__DATA_HISTOGRAM = 9,
  OPENTELEMETRY__PROTO__METRICS__V1__METRIC__DATA_EXPONENTIAL_HISTOGRAM = 10,
  OPENTELEMETRY__PROTO__METRICS__V1__METRIC__DATA_SUMMARY = 11
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(OPENTELEMETRY__PROTO__METRICS__V1__METRIC__DATA__CASE)
} Opentelemetry__Proto__Metrics__V1__Metric__DataCase;

/*
 * Defines a Metric which has one or more timeseries.  The following is a
 * brief summary of the Metric data model.  For more details, see:
 *   https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/data-model.md
 * The data model and relation between entities is shown in the
 * diagram below. Here, "DataPoint" is the term used to refer to any
 * one of the specific data point value types, and "points" is the term used
 * to refer to any one of the lists of points contained in the Metric.
 * - Metric is composed of a metadata and data.
 * - Metadata part contains a name, description, unit.
 * - Data is one of the possible types (Sum, Gauge, Histogram, Summary).
 * - DataPoint contains timestamps, attributes, and one of the possible value type
 *   fields.
 *    Metric
 *  +------------+
 *  |name        |
 *  |description |
 *  |unit        |     +------------------------------------+
 *  |data        |---> |Gauge, Sum, Histogram, Summary, ... |
 *  +------------+     +------------------------------------+
 *    Data [One of Gauge, Sum, Histogram, Summary, ...]
 *  +-----------+
 *  |...        |  // Metadata about the Data.
 *  |points     |--+
 *  +-----------+  |
 *                 |      +---------------------------+
 *                 |      |DataPoint 1                |
 *                 v      |+------+------+   +------+ |
 *              +-----+   ||label |label |...|label | |
 *              |  1  |-->||value1|value2|...|valueN| |
 *              +-----+   |+------+------+   +------+ |
 *              |  .  |   |+-----+                    |
 *              |  .  |   ||value|                    |
 *              |  .  |   |+-----+                    |
 *              |  .  |   +---------------------------+
 *              |  .  |                   .
 *              |  .  |                   .
 *              |  .  |                   .
 *              |  .  |   +---------------------------+
 *              |  .  |   |DataPoint M                |
 *              +-----+   |+------+------+   +------+ |
 *              |  M  |-->||label |label |...|label | |
 *              +-----+   ||value1|value2|...|valueN| |
 *                        |+------+------+   +------+ |
 *                        |+-----+                    |
 *                        ||value|                    |
 *                        |+-----+                    |
 *                        +---------------------------+
 * Each distinct type of DataPoint represents the output of a specific
 * aggregation function, the result of applying the DataPoint's
 * associated function of to one or more measurements.
 * All DataPoint types have three common fields:
 * - Attributes includes key-value pairs associated with the data point
 * - TimeUnixNano is required, set to the end time of the aggregation
 * - StartTimeUnixNano is optional, but strongly encouraged for DataPoints
 *   having an AggregationTemporality field, as discussed below.
 * Both TimeUnixNano and StartTimeUnixNano values are expressed as
 * UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
 * # TimeUnixNano
 * This field is required, having consistent interpretation across
 * DataPoint types.  TimeUnixNano is the moment corresponding to when
 * the data point's aggregate value was captured.
 * Data points with the 0 value for TimeUnixNano SHOULD be rejected
 * by consumers.
 * # StartTimeUnixNano
 * StartTimeUnixNano in general allows detecting when a sequence of
 * observations is unbroken.  This field indicates to consumers the
 * start time for points with cumulative and delta
 * AggregationTemporality, and it should be included whenever possible
 * to support correct rate calculation.  Although it may be omitted
 * when the start time is truly unknown, setting StartTimeUnixNano is
 * strongly encouraged.
 */
struct  Opentelemetry__Proto__Metrics__V1__Metric
{
  ProtobufCMessage base;
  /*
   * The name of the metric.
   */
  char *name;
  /*
   * A description of the metric, which can be used in documentation.
   */
  char *description;
  /*
   * The unit in which the metric value is reported. Follows the format
   * described by https://unitsofmeasure.org/ucum.html.
   */
  char *unit;
  /*
   * Additional metadata attributes that describe the metric. [Optional].
   * Attributes are non-identifying.
   * Consumers SHOULD NOT need to be aware of these attributes.
   * These attributes MAY be used to encode information allowing
   * for lossless roundtrip translation to / from another data model.
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   * The behavior of software that receives duplicated keys can be unpredictable.
   */
  size_t n_metadata;
  Opentelemetry__Proto__Common__V1__KeyValue **metadata;
  Opentelemetry__Proto__Metrics__V1__Metric__DataCase data_case;
  union {
    Opentelemetry__Proto__Metrics__V1__ExponentialHistogram *exponential_histogram;
    Opentelemetry__Proto__Metrics__V1__Gauge *gauge;
    Opentelemetry__Proto__Metrics__V1__Histogram *histogram;
    Opentelemetry__Proto__Metrics__V1__Sum *sum;
    Opentelemetry__Proto__Metrics__V1__Summary *summary;
  };
};
#define OPENTELEMETRY__PROTO__METRICS__V1__METRIC__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__metric__descriptor) \
, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0,NULL, OPENTELEMETRY__PROTO__METRICS__V1__METRIC__DATA__NOT_SET, {0} }


/*
 * Gauge represents the type of a scalar metric that always exports the
 * "current value" for every data point. It should be used for an "unknown"
 * aggregation.
 * A Gauge does not support different aggregation temporalities. Given the
 * aggregation is unknown, points cannot be combined using the same
 * aggregation, regardless of aggregation temporalities. Therefore,
 * AggregationTemporality is not included. Consequently, this also means
 * "StartTimeUnixNano" is ignored for all data points.
 */
struct  Opentelemetry__Proto__Metrics__V1__Gauge
{
  ProtobufCMessage base;
  /*
   * The time series data points.
   * Note: Multiple time series may be included (same timestamp, different attributes).
   */
  size_t n_data_points;
  Opentelemetry__Proto__Metrics__V1__NumberDataPoint **data_points;
};
#define OPENTELEMETRY__PROTO__METRICS__V1__GAUGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__gauge__descriptor) \
, 0,NULL }


/*
 * Sum represents the type of a scalar metric that is calculated as a sum of all
 * reported measurements over a time interval.
 */
struct  Opentelemetry__Proto__Metrics__V1__Sum
{
  ProtobufCMessage base;
  /*
   * The time series data points.
   * Note: Multiple time series may be included (same timestamp, different attributes).
   */
  size_t n_data_points;
  Opentelemetry__Proto__Metrics__V1__NumberDataPoint **data_points;
  /*
   * aggregation_temporality describes if the aggregator reports delta changes
   * since last report time, or cumulative changes since a fixed start time.
   */
  Opentelemetry__Proto__Metrics__V1__AggregationTemporality aggregation_temporality;
  /*
   * Represents whether the sum is monotonic.
   */
  protobuf_c_boolean is_monotonic;
};
#define OPENTELEMETRY__PROTO__METRICS__V1__SUM__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__sum__descriptor) \
, 0,NULL, OPENTELEMETRY__PROTO__METRICS__V1__AGGREGATION_TEMPORALITY__AGGREGATION_TEMPORALITY_UNSPECIFIED, 0 }


/*
 * Histogram represents the type of a metric that is calculated by aggregating
 * as a Histogram of all reported measurements over a time interval.
 */
struct  Opentelemetry__Proto__Metrics__V1__Histogram
{
  ProtobufCMessage base;
  /*
   * The time series data points.
   * Note: Multiple time series may be included (same timestamp, different attributes).
   */
  size_t n_data_points;
  Opentelemetry__Proto__Metrics__V1__HistogramDataPoint **data_points;
  /*
   * aggregation_temporality describes if the aggregator reports delta changes
   * since last report time, or cumulative changes since a fixed start time.
   */
  Opentelemetry__Proto__Metrics__V1__AggregationTemporality aggregation_temporality;
};
#define OPENTELEMETRY__PROTO__METRICS__V1__HISTOGRAM__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__histogram__descriptor) \
, 0,NULL, OPENTELEMETRY__PROTO__METRICS__V1__AGGREGATION_TEMPORALITY__AGGREGATION_TEMPORALITY_UNSPECIFIED }


/*
 * ExponentialHistogram represents the type of a metric that is calculated by aggregating
 * as a ExponentialHistogram of all reported double measurements over a time interval.
 */
struct  Opentelemetry__Proto__Metrics__V1__ExponentialHistogram
{
  ProtobufCMessage base;
  /*
   * The time series data points.
   * Note: Multiple time series may be included (same timestamp, different attributes).
   */
  size_t n_data_points;
  Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint **data_points;
  /*
   * aggregation_temporality describes if the aggregator reports delta changes
   * since last report time, or cumulative changes since a fixed start time.
   */
  Opentelemetry__Proto__Metrics__V1__AggregationTemporality aggregation_temporality;
};
#define OPENTELEMETRY__PROTO__METRICS__V1__EXPONENTIAL_HISTOGRAM__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__exponential_histogram__descriptor) \
, 0,NULL, OPENTELEMETRY__PROTO__METRICS__V1__AGGREGATION_TEMPORALITY__AGGREGATION_TEMPORALITY_UNSPECIFIED }


/*
 * Summary metric data are used to convey quantile summaries,
 * a Prometheus (see: https://prometheus.io/docs/concepts/metric_types/#summary)
 * and OpenMetrics (see: https://github.com/prometheus/OpenMetrics/blob/4dbf6075567ab43296eed941037c12951faafb92/protos/prometheus.proto#L45)
 * data type. These data points cannot always be merged in a meaningful way.
 * While they can be useful in some applications, histogram data points are
 * recommended for new applications.
 * Summary metrics do not have an aggregation temporality field. This is
 * because the count and sum fields of a SummaryDataPoint are assumed to be
 * cumulative values.
 */
struct  Opentelemetry__Proto__Metrics__V1__Summary
{
  ProtobufCMessage base;
  /*
   * The time series data points.
   * Note: Multiple time series may be included (same timestamp, different attributes).
   */
  size_t n_data_points;
  Opentelemetry__Proto__Metrics__V1__SummaryDataPoint **data_points;
};
#define OPENTELEMETRY__PROTO__METRICS__V1__SUMMARY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__summary__descriptor) \
, 0,NULL }


typedef enum {
  OPENTELEMETRY__PROTO__METRICS__V1__NUMBER_DATA_POINT__VALUE__NOT_SET = 0,
  OPENTELEMETRY__PROTO__METRICS__V1__NUMBER_DATA_POINT__VALUE_AS_DOUBLE = 4,
  OPENTELEMETRY__PROTO__METRICS__V1__NUMBER_DATA_POINT__VALUE_AS_INT = 6
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(OPENTELEMETRY__PROTO__METRICS__V1__NUMBER_DATA_POINT__VALUE__CASE)
} Opentelemetry__Proto__Metrics__V1__NumberDataPoint__ValueCase;

/*
 * NumberDataPoint is a single data point in a timeseries that describes the
 * time-varying scalar value of a metric.
 */
struct  Opentelemetry__Proto__Metrics__V1__NumberDataPoint
{
  ProtobufCMessage base;
  /*
   * The set of key/value pairs that uniquely identify the timeseries from
   * where this point belongs. The list may be empty (may contain 0 elements).
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   * The behavior of software that receives duplicated keys can be unpredictable.
   */
  size_t n_attributes;
  Opentelemetry__Proto__Common__V1__KeyValue **attributes;
  /*
   * StartTimeUnixNano is optional but strongly encouraged, see the
   * the detailed comments above Metric.
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   */
  uint64_t start_time_unix_nano;
  /*
   * TimeUnixNano is required, see the detailed comments above Metric.
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   */
  uint64_t time_unix_nano;
  /*
   * (Optional) List of exemplars collected from
   * measurements that were used to form the data point
   */
  size_t n_exemplars;
  Opentelemetry__Proto__Metrics__V1__Exemplar **exemplars;
  /*
   * Flags that apply to this specific data point.  See DataPointFlags
   * for the available flags and their meaning.
   */
  uint32_t flags;
  Opentelemetry__Proto__Metrics__V1__NumberDataPoint__ValueCase value_case;
  union {
    double as_double;
    int64_t as_int;
  };
};
#define OPENTELEMETRY__PROTO__METRICS__V1__NUMBER_DATA_POINT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__number_data_point__descriptor) \
, 0,NULL, 0, 0, 0,NULL, 0, OPENTELEMETRY__PROTO__METRICS__V1__NUMBER_DATA_POINT__VALUE__NOT_SET, {0} }


/*
 * HistogramDataPoint is a single data point in a timeseries that describes the
 * time-varying values of a Histogram. A Histogram contains summary statistics
 * for a population of values, it may optionally contain the distribution of
 * those values across a set of buckets.
 * If the histogram contains the distribution of values, then both
 * "explicit_bounds" and "bucket counts" fields must be defined.
 * If the histogram does not contain the distribution of values, then both
 * "explicit_bounds" and "bucket_counts" must be omitted and only "count" and
 * "sum" are known.
 */
struct  Opentelemetry__Proto__Metrics__V1__HistogramDataPoint
{
  ProtobufCMessage base;
  /*
   * The set of key/value pairs that uniquely identify the timeseries from
   * where this point belongs. The list may be empty (may contain 0 elements).
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   * The behavior of software that receives duplicated keys can be unpredictable.
   */
  size_t n_attributes;
  Opentelemetry__Proto__Common__V1__KeyValue **attributes;
  /*
   * StartTimeUnixNano is optional but strongly encouraged, see the
   * the detailed comments above Metric.
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   */
  uint64_t start_time_unix_nano;
  /*
   * TimeUnixNano is required, see the detailed comments above Metric.
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   */
  uint64_t time_unix_nano;
  /*
   * count is the number of values in the population. Must be non-negative. This
   * value must be equal to the sum of the "count" fields in buckets if a
   * histogram is provided.
   */
  uint64_t count;
  /*
   * sum of the values in the population. If count is zero then this field
   * must be zero.
   * Note: Sum should only be filled out when measuring non-negative discrete
   * events, and is assumed to be monotonic over the values of these events.
   * Negative events *can* be recorded, but sum should not be filled out when
   * doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
   * see: https://github.com/prometheus/OpenMetrics/blob/v1.0.0/specification/OpenMetrics.md#histogram
   */
  protobuf_c_boolean has_sum;
  double sum;
  /*
   * bucket_counts is an optional field contains the count values of histogram
   * for each bucket.
   * The sum of the bucket_counts must equal the value in the count field.
   * The number of elements in bucket_counts array must be by one greater than
   * the number of elements in explicit_bounds array. The exception to this rule
   * is when the length of bucket_counts is 0, then the length of explicit_bounds
   * must also be 0.
   */
  size_t n_bucket_counts;
  uint64_t *bucket_counts;
  /*
   * explicit_bounds specifies buckets with explicitly defined bounds for values.
   * The boundaries for bucket at index i are:
   * (-infinity, explicit_bounds[i]] for i == 0
   * (explicit_bounds[i-1], explicit_bounds[i]] for 0 < i < size(explicit_bounds)
   * (explicit_bounds[i-1], +infinity) for i == size(explicit_bounds)
   * The values in the explicit_bounds array must be strictly increasing.
   * Histogram buckets are inclusive of their upper boundary, except the last
   * bucket where the boundary is at infinity. This format is intentionally
   * compatible with the OpenMetrics histogram definition.
   * If bucket_counts length is 0 then explicit_bounds length must also be 0,
   * otherwise the data point is invalid.
   */
  size_t n_explicit_bounds;
  double *explicit_bounds;
  /*
   * (Optional) List of exemplars collected from
   * measurements that were used to form the data point
   */
  size_t n_exemplars;
  Opentelemetry__Proto__Metrics__V1__Exemplar **exemplars;
  /*
   * Flags that apply to this specific data point.  See DataPointFlags
   * for the available flags and their meaning.
   */
  uint32_t flags;
  /*
   * min is the minimum value over (start_time, end_time].
   */
  protobuf_c_boolean has_min;
  double min;
  /*
   * max is the maximum value over (start_time, end_time].
   */
  protobuf_c_boolean has_max;
  double max;
};
#define OPENTELEMETRY__PROTO__METRICS__V1__HISTOGRAM_DATA_POINT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__histogram_data_point__descriptor) \
, 0,NULL, 0, 0, 0, 0, 0, 0,NULL, 0,NULL, 0,NULL, 0, 0, 0, 0, 0 }


/*
 * Buckets are a set of bucket counts, encoded in a contiguous array
 * of counts.
 */
struct  Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint__Buckets
{
  ProtobufCMessage base;
  /*
   * The bucket index of the first entry in the bucket_counts array.
   * Note: This uses a varint encoding as a simple form of compression.
   */
  int32_t offset;
  /*
   * An array of count values, where bucket_counts[i] carries
   * the count of the bucket at index (offset+i). bucket_counts[i] is the count
   * of values greater than base^(offset+i) and less than or equal to
   * base^(offset+i+1).
   * Note: By contrast, the explicit HistogramDataPoint uses
   * fixed64.  This field is expected to have many buckets,
   * especially zeros, so uint64 has been selected to ensure
   * varint encoding.
   */
  size_t n_bucket_counts;
  uint64_t *bucket_counts;
};
#define OPENTELEMETRY__PROTO__METRICS__V1__EXPONENTIAL_HISTOGRAM_DATA_POINT__BUCKETS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__exponential_histogram_data_point__buckets__descriptor) \
, 0, 0,NULL }


/*
 * ExponentialHistogramDataPoint is a single data point in a timeseries that describes the
 * time-varying values of a ExponentialHistogram of double values. A ExponentialHistogram contains
 * summary statistics for a population of values, it may optionally contain the
 * distribution of those values across a set of buckets.
 */
struct  Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint
{
  ProtobufCMessage base;
  /*
   * The set of key/value pairs that uniquely identify the timeseries from
   * where this point belongs. The list may be empty (may contain 0 elements).
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   * The behavior of software that receives duplicated keys can be unpredictable.
   */
  size_t n_attributes;
  Opentelemetry__Proto__Common__V1__KeyValue **attributes;
  /*
   * StartTimeUnixNano is optional but strongly encouraged, see the
   * the detailed comments above Metric.
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   */
  uint64_t start_time_unix_nano;
  /*
   * TimeUnixNano is required, see the detailed comments above Metric.
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   */
  uint64_t time_unix_nano;
  /*
   * The number of values in the population. Must be
   * non-negative. This value must be equal to the sum of the "bucket_counts"
   * values in the positive and negative Buckets plus the "zero_count" field.
   */
  uint64_t count;
  /*
   * The sum of the values in the population. If count is zero then this field
   * must be zero.
   * Note: Sum should only be filled out when measuring non-negative discrete
   * events, and is assumed to be monotonic over the values of these events.
   * Negative events *can* be recorded, but sum should not be filled out when
   * doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
   * see: https://github.com/prometheus/OpenMetrics/blob/v1.0.0/specification/OpenMetrics.md#histogram
   */
  protobuf_c_boolean has_sum;
  double sum;
  /*
   * scale describes the resolution of the histogram.  Boundaries are
   * located at powers of the base, where:
   *   base = (2^(2^-scale))
   * The histogram bucket identified by `index`, a signed integer,
   * contains values that are greater than (base^index) and
   * less than or equal to (base^(index+1)).
   * The positive and negative ranges of the histogram are expressed
   * separately.  Negative values are mapped by their absolute value
   * into the negative range using the same scale as the positive range.
   * scale is not restricted by the protocol, as the permissible
   * values depend on the range of the data.
   */
  int32_t scale;
  /*
   * The count of values that are either exactly zero or
   * within the region considered zero by the instrumentation at the
   * tolerated degree of precision.  This bucket stores values that
   * cannot be expressed using the standard exponential formula as
   * well as values that have been rounded to zero.
   * Implementations MAY consider the zero bucket to have probability
   * mass equal to (zero_count / count).
   */
  uint64_t zero_count;
  /*
   * positive carries the positive range of exponential bucket counts.
   */
  Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint__Buckets *positive;
  /*
   * negative carries the negative range of exponential bucket counts.
   */
  Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint__Buckets *negative;
  /*
   * Flags that apply to this specific data point.  See DataPointFlags
   * for the available flags and their meaning.
   */
  uint32_t flags;
  /*
   * (Optional) List of exemplars collected from
   * measurements that were used to form the data point
   */
  size_t n_exemplars;
  Opentelemetry__Proto__Metrics__V1__Exemplar **exemplars;
  /*
   * The minimum value over (start_time, end_time].
   */
  protobuf_c_boolean has_min;
  double min;
  /*
   * The maximum value over (start_time, end_time].
   */
  protobuf_c_boolean has_max;
  double max;
  /*
   * ZeroThreshold may be optionally set to convey the width of the zero
   * region. Where the zero region is defined as the closed interval
   * [-ZeroThreshold, ZeroThreshold].
   * When ZeroThreshold is 0, zero count bucket stores values that cannot be
   * expressed using the standard exponential formula as well as values that
   * have been rounded to zero.
   */
  double zero_threshold;
};
#define OPENTELEMETRY__PROTO__METRICS__V1__EXPONENTIAL_HISTOGRAM_DATA_POINT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__exponential_histogram_data_point__descriptor) \
, 0,NULL, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0,NULL, 0, 0, 0, 0, 0 }


/*
 * Represents the value at a given quantile of a distribution.
 * To record Min and Max values following conventions are used:
 * - The 1.0 quantile is equivalent to the maximum value observed.
 * - The 0.0 quantile is equivalent to the minimum value observed.
 * See the following issue for more context:
 * https://github.com/open-telemetry/opentelemetry-proto/issues/125
 */
struct  Opentelemetry__Proto__Metrics__V1__SummaryDataPoint__ValueAtQuantile
{
  ProtobufCMessage base;
  /*
   * The quantile of a distribution. Must be in the interval
   * [0.0, 1.0].
   */
  double quantile;
  /*
   * The value at the given quantile of a distribution.
   * Quantile values must NOT be negative.
   */
  double value;
};
#define OPENTELEMETRY__PROTO__METRICS__V1__SUMMARY_DATA_POINT__VALUE_AT_QUANTILE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__summary_data_point__value_at_quantile__descriptor) \
, 0, 0 }


/*
 * SummaryDataPoint is a single data point in a timeseries that describes the
 * time-varying values of a Summary metric. The count and sum fields represent
 * cumulative values.
 */
struct  Opentelemetry__Proto__Metrics__V1__SummaryDataPoint
{
  ProtobufCMessage base;
  /*
   * The set of key/value pairs that uniquely identify the timeseries from
   * where this point belongs. The list may be empty (may contain 0 elements).
   * Attribute keys MUST be unique (it is not allowed to have more than one
   * attribute with the same key).
   * The behavior of software that receives duplicated keys can be unpredictable.
   */
  size_t n_attributes;
  Opentelemetry__Proto__Common__V1__KeyValue **attributes;
  /*
   * StartTimeUnixNano is optional but strongly encouraged, see the
   * the detailed comments above Metric.
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   */
  uint64_t start_time_unix_nano;
  /*
   * TimeUnixNano is required, see the detailed comments above Metric.
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   */
  uint64_t time_unix_nano;
  /*
   * count is the number of values in the population. Must be non-negative.
   */
  uint64_t count;
  /*
   * sum of the values in the population. If count is zero then this field
   * must be zero.
   * Note: Sum should only be filled out when measuring non-negative discrete
   * events, and is assumed to be monotonic over the values of these events.
   * Negative events *can* be recorded, but sum should not be filled out when
   * doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
   * see: https://github.com/prometheus/OpenMetrics/blob/v1.0.0/specification/OpenMetrics.md#summary
   */
  double sum;
  /*
   * (Optional) list of values at different quantiles of the distribution calculated
   * from the current snapshot. The quantiles must be strictly increasing.
   */
  size_t n_quantile_values;
  Opentelemetry__Proto__Metrics__V1__SummaryDataPoint__ValueAtQuantile **quantile_values;
  /*
   * Flags that apply to this specific data point.  See DataPointFlags
   * for the available flags and their meaning.
   */
  uint32_t flags;
};
#define OPENTELEMETRY__PROTO__METRICS__V1__SUMMARY_DATA_POINT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__summary_data_point__descriptor) \
, 0,NULL, 0, 0, 0, 0, 0,NULL, 0 }


typedef enum {
  OPENTELEMETRY__PROTO__METRICS__V1__EXEMPLAR__VALUE__NOT_SET = 0,
  OPENTELEMETRY__PROTO__METRICS__V1__EXEMPLAR__VALUE_AS_DOUBLE = 3,
  OPENTELEMETRY__PROTO__METRICS__V1__EXEMPLAR__VALUE_AS_INT = 6
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(OPENTELEMETRY__PROTO__METRICS__V1__EXEMPLAR__VALUE__CASE)
} Opentelemetry__Proto__Metrics__V1__Exemplar__ValueCase;

/*
 * A representation of an exemplar, which is a sample input measurement.
 * Exemplars also hold information about the environment when the measurement
 * was recorded, for example the span and trace ID of the active span when the
 * exemplar was recorded.
 */
struct  Opentelemetry__Proto__Metrics__V1__Exemplar
{
  ProtobufCMessage base;
  /*
   * The set of key/value pairs that were filtered out by the aggregator, but
   * recorded alongside the original measurement. Only key/value pairs that were
   * filtered out by the aggregator should be included
   */
  size_t n_filtered_attributes;
  Opentelemetry__Proto__Common__V1__KeyValue **filtered_attributes;
  /*
   * time_unix_nano is the exact time when this exemplar was recorded
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
   * 1970.
   */
  uint64_t time_unix_nano;
  /*
   * (Optional) Span ID of the exemplar trace.
   * span_id may be missing if the measurement is not recorded inside a trace
   * or if the trace is not sampled.
   */
  ProtobufCBinaryData span_id;
  /*
   * (Optional) Trace ID of the exemplar trace.
   * trace_id may be missing if the measurement is not recorded inside a trace
   * or if the trace is not sampled.
   */
  ProtobufCBinaryData trace_id;
  Opentelemetry__Proto__Metrics__V1__Exemplar__ValueCase value_case;
  union {
    double as_double;
    int64_t as_int;
  };
};
#define OPENTELEMETRY__PROTO__METRICS__V1__EXEMPLAR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&opentelemetry__proto__metrics__v1__exemplar__descriptor) \
, 0,NULL, 0, {0,NULL}, {0,NULL}, OPENTELEMETRY__PROTO__METRICS__V1__EXEMPLAR__VALUE__NOT_SET, {0} }


/* Opentelemetry__Proto__Metrics__V1__MetricsData methods */
void   opentelemetry__proto__metrics__v1__metrics_data__init
                     (Opentelemetry__Proto__Metrics__V1__MetricsData         *message);
size_t opentelemetry__proto__metrics__v1__metrics_data__get_packed_size
                     (const Opentelemetry__Proto__Metrics__V1__MetricsData   *message);
size_t opentelemetry__proto__metrics__v1__metrics_data__pack
                     (const Opentelemetry__Proto__Metrics__V1__MetricsData   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__metrics__v1__metrics_data__pack_to_buffer
                     (const Opentelemetry__Proto__Metrics__V1__MetricsData   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Metrics__V1__MetricsData *
       opentelemetry__proto__metrics__v1__metrics_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__metrics__v1__metrics_data__free_unpacked
                     (Opentelemetry__Proto__Metrics__V1__MetricsData *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Metrics__V1__ResourceMetrics methods */
void   opentelemetry__proto__metrics__v1__resource_metrics__init
                     (Opentelemetry__Proto__Metrics__V1__ResourceMetrics         *message);
size_t opentelemetry__proto__metrics__v1__resource_metrics__get_packed_size
                     (const Opentelemetry__Proto__Metrics__V1__ResourceMetrics   *message);
size_t opentelemetry__proto__metrics__v1__resource_metrics__pack
                     (const Opentelemetry__Proto__Metrics__V1__ResourceMetrics   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__metrics__v1__resource_metrics__pack_to_buffer
                     (const Opentelemetry__Proto__Metrics__V1__ResourceMetrics   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Metrics__V1__ResourceMetrics *
       opentelemetry__proto__metrics__v1__resource_metrics__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__metrics__v1__resource_metrics__free_unpacked
                     (Opentelemetry__Proto__Metrics__V1__ResourceMetrics *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Metrics__V1__ScopeMetrics methods */
void   opentelemetry__proto__metrics__v1__scope_metrics__init
                     (Opentelemetry__Proto__Metrics__V1__ScopeMetrics         *message);
size_t opentelemetry__proto__metrics__v1__scope_metrics__get_packed_size
                     (const Opentelemetry__Proto__Metrics__V1__ScopeMetrics   *message);
size_t opentelemetry__proto__metrics__v1__scope_metrics__pack
                     (const Opentelemetry__Proto__Metrics__V1__ScopeMetrics   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__metrics__v1__scope_metrics__pack_to_buffer
                     (const Opentelemetry__Proto__Metrics__V1__ScopeMetrics   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Metrics__V1__ScopeMetrics *
       opentelemetry__proto__metrics__v1__scope_metrics__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__metrics__v1__scope_metrics__free_unpacked
                     (Opentelemetry__Proto__Metrics__V1__ScopeMetrics *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Metrics__V1__Metric methods */
void   opentelemetry__proto__metrics__v1__metric__init
                     (Opentelemetry__Proto__Metrics__V1__Metric         *message);
size_t opentelemetry__proto__metrics__v1__metric__get_packed_size
                     (const Opentelemetry__Proto__Metrics__V1__Metric   *message);
size_t opentelemetry__proto__metrics__v1__metric__pack
                     (const Opentelemetry__Proto__Metrics__V1__Metric   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__metrics__v1__metric__pack_to_buffer
                     (const Opentelemetry__Proto__Metrics__V1__Metric   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Metrics__V1__Metric *
       opentelemetry__proto__metrics__v1__metric__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__metrics__v1__metric__free_unpacked
                     (Opentelemetry__Proto__Metrics__V1__Metric *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Metrics__V1__Gauge methods */
void   opentelemetry__proto__metrics__v1__gauge__init
                     (Opentelemetry__Proto__Metrics__V1__Gauge         *message);
size_t opentelemetry__proto__metrics__v1__gauge__get_packed_size
                     (const Opentelemetry__Proto__Metrics__V1__Gauge   *message);
size_t opentelemetry__proto__metrics__v1__gauge__pack
                     (const Opentelemetry__Proto__Metrics__V1__Gauge   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__metrics__v1__gauge__pack_to_buffer
                     (const Opentelemetry__Proto__Metrics__V1__Gauge   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Metrics__V1__Gauge *
       opentelemetry__proto__metrics__v1__gauge__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__metrics__v1__gauge__free_unpacked
                     (Opentelemetry__Proto__Metrics__V1__Gauge *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Metrics__V1__Sum methods */
void   opentelemetry__proto__metrics__v1__sum__init
                     (Opentelemetry__Proto__Metrics__V1__Sum         *message);
size_t opentelemetry__proto__metrics__v1__sum__get_packed_size
                     (const Opentelemetry__Proto__Metrics__V1__Sum   *message);
size_t opentelemetry__proto__metrics__v1__sum__pack
                     (const Opentelemetry__Proto__Metrics__V1__Sum   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__metrics__v1__sum__pack_to_buffer
                     (const Opentelemetry__Proto__Metrics__V1__Sum   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Metrics__V1__Sum *
       opentelemetry__proto__metrics__v1__sum__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__metrics__v1__sum__free_unpacked
                     (Opentelemetry__Proto__Metrics__V1__Sum *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Metrics__V1__Histogram methods */
void   opentelemetry__proto__metrics__v1__histogram__init
                     (Opentelemetry__Proto__Metrics__V1__Histogram         *message);
size_t opentelemetry__proto__metrics__v1__histogram__get_packed_size
                     (const Opentelemetry__Proto__Metrics__V1__Histogram   *message);
size_t opentelemetry__proto__metrics__v1__histogram__pack
                     (const Opentelemetry__Proto__Metrics__V1__Histogram   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__metrics__v1__histogram__pack_to_buffer
                     (const Opentelemetry__Proto__Metrics__V1__Histogram   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Metrics__V1__Histogram *
       opentelemetry__proto__metrics__v1__histogram__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__metrics__v1__histogram__free_unpacked
                     (Opentelemetry__Proto__Metrics__V1__Histogram *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Metrics__V1__ExponentialHistogram methods */
void   opentelemetry__proto__metrics__v1__exponential_histogram__init
                     (Opentelemetry__Proto__Metrics__V1__ExponentialHistogram         *message);
size_t opentelemetry__proto__metrics__v1__exponential_histogram__get_packed_size
                     (const Opentelemetry__Proto__Metrics__V1__ExponentialHistogram   *message);
size_t opentelemetry__proto__metrics__v1__exponential_histogram__pack
                     (const Opentelemetry__Proto__Metrics__V1__ExponentialHistogram   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__metrics__v1__exponential_histogram__pack_to_buffer
                     (const Opentelemetry__Proto__Metrics__V1__ExponentialHistogram   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Metrics__V1__ExponentialHistogram *
       opentelemetry__proto__metrics__v1__exponential_histogram__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__metrics__v1__exponential_histogram__free_unpacked
                     (Opentelemetry__Proto__Metrics__V1__ExponentialHistogram *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Metrics__V1__Summary methods */
void   opentelemetry__proto__metrics__v1__summary__init
                     (Opentelemetry__Proto__Metrics__V1__Summary         *message);
size_t opentelemetry__proto__metrics__v1__summary__get_packed_size
                     (const Opentelemetry__Proto__Metrics__V1__Summary   *message);
size_t opentelemetry__proto__metrics__v1__summary__pack
                     (const Opentelemetry__Proto__Metrics__V1__Summary   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__metrics__v1__summary__pack_to_buffer
                     (const Opentelemetry__Proto__Metrics__V1__Summary   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Metrics__V1__Summary *
       opentelemetry__proto__metrics__v1__summary__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__metrics__v1__summary__free_unpacked
                     (Opentelemetry__Proto__Metrics__V1__Summary *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Metrics__V1__NumberDataPoint methods */
void   opentelemetry__proto__metrics__v1__number_data_point__init
                     (Opentelemetry__Proto__Metrics__V1__NumberDataPoint         *message);
size_t opentelemetry__proto__metrics__v1__number_data_point__get_packed_size
                     (const Opentelemetry__Proto__Metrics__V1__NumberDataPoint   *message);
size_t opentelemetry__proto__metrics__v1__number_data_point__pack
                     (const Opentelemetry__Proto__Metrics__V1__NumberDataPoint   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__metrics__v1__number_data_point__pack_to_buffer
                     (const Opentelemetry__Proto__Metrics__V1__NumberDataPoint   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Metrics__V1__NumberDataPoint *
       opentelemetry__proto__metrics__v1__number_data_point__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__metrics__v1__number_data_point__free_unpacked
                     (Opentelemetry__Proto__Metrics__V1__NumberDataPoint *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Metrics__V1__HistogramDataPoint methods */
void   opentelemetry__proto__metrics__v1__histogram_data_point__init
                     (Opentelemetry__Proto__Metrics__V1__HistogramDataPoint         *message);
size_t opentelemetry__proto__metrics__v1__histogram_data_point__get_packed_size
                     (const Opentelemetry__Proto__Metrics__V1__HistogramDataPoint   *message);
size_t opentelemetry__proto__metrics__v1__histogram_data_point__pack
                     (const Opentelemetry__Proto__Metrics__V1__HistogramDataPoint   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__metrics__v1__histogram_data_point__pack_to_buffer
                     (const Opentelemetry__Proto__Metrics__V1__HistogramDataPoint   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Metrics__V1__HistogramDataPoint *
       opentelemetry__proto__metrics__v1__histogram_data_point__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__metrics__v1__histogram_data_point__free_unpacked
                     (Opentelemetry__Proto__Metrics__V1__HistogramDataPoint *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint__Buckets methods */
void   opentelemetry__proto__metrics__v1__exponential_histogram_data_point__buckets__init
                     (Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint__Buckets         *message);
/* Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint methods */
void   opentelemetry__proto__metrics__v1__exponential_histogram_data_point__init
                     (Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint         *message);
size_t opentelemetry__proto__metrics__v1__exponential_histogram_data_point__get_packed_size
                     (const Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint   *message);
size_t opentelemetry__proto__metrics__v1__exponential_histogram_data_point__pack
                     (const Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__metrics__v1__exponential_histogram_data_point__pack_to_buffer
                     (const Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint *
       opentelemetry__proto__metrics__v1__exponential_histogram_data_point__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__metrics__v1__exponential_histogram_data_point__free_unpacked
                     (Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Metrics__V1__SummaryDataPoint__ValueAtQuantile methods */
void   opentelemetry__proto__metrics__v1__summary_data_point__value_at_quantile__init
                     (Opentelemetry__Proto__Metrics__V1__SummaryDataPoint__ValueAtQuantile         *message);
/* Opentelemetry__Proto__Metrics__V1__SummaryDataPoint methods */
void   opentelemetry__proto__metrics__v1__summary_data_point__init
                     (Opentelemetry__Proto__Metrics__V1__SummaryDataPoint         *message);
size_t opentelemetry__proto__metrics__v1__summary_data_point__get_packed_size
                     (const Opentelemetry__Proto__Metrics__V1__SummaryDataPoint   *message);
size_t opentelemetry__proto__metrics__v1__summary_data_point__pack
                     (const Opentelemetry__Proto__Metrics__V1__SummaryDataPoint   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__metrics__v1__summary_data_point__pack_to_buffer
                     (const Opentelemetry__Proto__Metrics__V1__SummaryDataPoint   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Metrics__V1__SummaryDataPoint *
       opentelemetry__proto__metrics__v1__summary_data_point__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__metrics__v1__summary_data_point__free_unpacked
                     (Opentelemetry__Proto__Metrics__V1__SummaryDataPoint *message,
                      ProtobufCAllocator *allocator);
/* Opentelemetry__Proto__Metrics__V1__Exemplar methods */
void   opentelemetry__proto__metrics__v1__exemplar__init
                     (Opentelemetry__Proto__Metrics__V1__Exemplar         *message);
size_t opentelemetry__proto__metrics__v1__exemplar__get_packed_size
                     (const Opentelemetry__Proto__Metrics__V1__Exemplar   *message);
size_t opentelemetry__proto__metrics__v1__exemplar__pack
                     (const Opentelemetry__Proto__Metrics__V1__Exemplar   *message,
                      uint8_t             *out);
size_t opentelemetry__proto__metrics__v1__exemplar__pack_to_buffer
                     (const Opentelemetry__Proto__Metrics__V1__Exemplar   *message,
                      ProtobufCBuffer     *buffer);
Opentelemetry__Proto__Metrics__V1__Exemplar *
       opentelemetry__proto__metrics__v1__exemplar__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   opentelemetry__proto__metrics__v1__exemplar__free_unpacked
                     (Opentelemetry__Proto__Metrics__V1__Exemplar *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Opentelemetry__Proto__Metrics__V1__MetricsData_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__MetricsData *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Metrics__V1__ResourceMetrics_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__ResourceMetrics *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Metrics__V1__ScopeMetrics_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__ScopeMetrics *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Metrics__V1__Metric_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__Metric *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Metrics__V1__Gauge_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__Gauge *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Metrics__V1__Sum_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__Sum *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Metrics__V1__Histogram_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__Histogram *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Metrics__V1__ExponentialHistogram_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__ExponentialHistogram *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Metrics__V1__Summary_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__Summary *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Metrics__V1__NumberDataPoint_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__NumberDataPoint *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Metrics__V1__HistogramDataPoint_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__HistogramDataPoint *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint__Buckets_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint__Buckets *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__ExponentialHistogramDataPoint *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Metrics__V1__SummaryDataPoint__ValueAtQuantile_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__SummaryDataPoint__ValueAtQuantile *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Metrics__V1__SummaryDataPoint_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__SummaryDataPoint *message,
                  void *closure_data);
typedef void (*Opentelemetry__Proto__Metrics__V1__Exemplar_Closure)
                 (const Opentelemetry__Proto__Metrics__V1__Exemplar *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    opentelemetry__proto__metrics__v1__aggregation_temporality__descriptor;
extern const ProtobufCEnumDescriptor    opentelemetry__proto__metrics__v1__data_point_flags__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__metrics_data__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__resource_metrics__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__scope_metrics__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__metric__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__gauge__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__sum__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__histogram__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__exponential_histogram__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__summary__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__number_data_point__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__histogram_data_point__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__exponential_histogram_data_point__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__exponential_histogram_data_point__buckets__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__summary_data_point__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__summary_data_point__value_at_quantile__descriptor;
extern const ProtobufCMessageDescriptor opentelemetry__proto__metrics__v1__exemplar__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_opentelemetry_2fproto_2fmetrics_2fv1_2fmetrics_2eproto__INCLUDED */
