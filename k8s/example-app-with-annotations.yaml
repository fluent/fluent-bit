---
# Example Applications with Parseable Annotations
# These examples show how to use annotations to route logs to different Parseable streams

# Example 1: Simple web application
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-frontend
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: web-frontend
  template:
    metadata:
      labels:
        app: web-frontend
        environment: production
      annotations:
        # Parseable routing annotations
        parseable/dataset: "frontend-logs"
        parseable/env: "production"
        parseable/service: "web-frontend"
        parseable/version: "v2.1.0"
        parseable/log-source: "kubernetes"
    spec:
      containers:
      - name: frontend
        image: nginx:alpine
        ports:
        - containerPort: 80

---
# Example 2: Backend API with JSON logs
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-backend
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api-backend
  template:
    metadata:
      labels:
        app: api-backend
        environment: production
      annotations:
        parseable/dataset: "backend-api-logs"
        parseable/env: "production"
        parseable/service: "api-backend"
        parseable/version: "v3.0.1"
        # Use JSON parser for structured logs
        fluentbit.io/parser: "json"
    spec:
      containers:
      - name: api
        image: hashicorp/http-echo
        args:
          - "-text=Hello from API"
        ports:
        - containerPort: 5678

---
# Example 3: Database with separate stream
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres-db
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
        environment: production
      annotations:
        parseable/dataset: "database-logs"
        parseable/env: "production"
        parseable/service: "postgres"
        parseable/version: "15.2"
    spec:
      containers:
      - name: postgres
        image: postgres:15-alpine
        env:
        - name: POSTGRES_PASSWORD
          value: "example"
        ports:
        - containerPort: 5432

---
# Example 4: Worker with excluded debug container
apiVersion: apps/v1
kind: Deployment
metadata:
  name: background-worker
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: worker
  template:
    metadata:
      labels:
        app: worker
        environment: production
      annotations:
        parseable/dataset: "worker-logs"
        parseable/env: "production"
        parseable/service: "background-worker"
        parseable/version: "v1.5.0"
        # Exclude debug sidecar container logs
        parseable/exclude-debug: "true"
    spec:
      containers:
      - name: worker
        image: busybox
        command: ["sh", "-c", "while true; do echo 'Processing job...'; sleep 5; done"]
      - name: debug
        image: busybox
        command: ["sh", "-c", "while true; do echo 'Debug info...'; sleep 1; done"]

---
# Example 5: Staging environment (different stream)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-frontend-staging
  namespace: staging
spec:
  replicas: 1
  selector:
    matchLabels:
      app: web-frontend
  template:
    metadata:
      labels:
        app: web-frontend
        environment: staging
      annotations:
        parseable/dataset: "staging-logs"
        parseable/env: "staging"
        parseable/service: "web-frontend"
        parseable/version: "v2.2.0-beta"
    spec:
      containers:
      - name: frontend
        image: nginx:alpine

---
# Example 6: Completely excluded pod (health checks, etc.)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: health-checker
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: health-checker
  template:
    metadata:
      labels:
        app: health-checker
      annotations:
        # Exclude all logs from this pod
        parseable/exclude: "true"
    spec:
      containers:
      - name: checker
        image: busybox
        command: ["sh", "-c", "while true; do echo 'Health check...'; sleep 10; done"]

---
# Example 7: OpenTelemetry instrumented application
apiVersion: apps/v1
kind: Deployment
metadata:
  name: otel-instrumented-app
  namespace: default
spec:
  replicas: 2
  selector:
    matchLabels:
      app: otel-app
  template:
    metadata:
      labels:
        app: otel-app
        environment: production
      annotations:
        parseable/dataset: "otel-app-logs"
        parseable/env: "production"
        parseable/service: "otel-instrumented-app"
        parseable/version: "v1.0.0"
        parseable/log-source: "otel-logs"
    spec:
      containers:
      - name: app
        image: your-otel-app:latest
        env:
        # Configure OTEL to send to Fluent Bit
        - name: OTEL_EXPORTER_OTLP_ENDPOINT
          value: "http://fluent-bit.parseable-logging.svc.cluster.local:4317"
        - name: OTEL_SERVICE_NAME
          value: "otel-instrumented-app"
        ports:
        - containerPort: 8080

---
# Example 8: Microservices with namespace-based routing
apiVersion: v1
kind: Namespace
metadata:
  name: ecommerce
  labels:
    parseable/default-stream: "ecommerce-logs"

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cart-service
  namespace: ecommerce
spec:
  replicas: 2
  selector:
    matchLabels:
      app: cart-service
  template:
    metadata:
      labels:
        app: cart-service
        app.kubernetes.io/name: cart-service
        app.kubernetes.io/version: "v1.2.0"
      annotations:
        # Will use "cart-service-logs" stream (derived from app label)
        parseable/env: "production"
        parseable/service: "cart-service"
    spec:
      containers:
      - name: cart
        image: your-cart-service:v1.2.0
        ports:
        - containerPort: 8080

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: checkout-service
  namespace: ecommerce
spec:
  replicas: 2
  selector:
    matchLabels:
      app: checkout-service
  template:
    metadata:
      labels:
        app: checkout-service
        app.kubernetes.io/name: checkout-service
        app.kubernetes.io/version: "v2.0.0"
      annotations:
        # Explicit stream override
        parseable/dataset: "checkout-logs"
        parseable/env: "production"
        parseable/service: "checkout-service"
    spec:
      containers:
      - name: checkout
        image: your-checkout-service:v2.0.0
        ports:
        - containerPort: 8080
